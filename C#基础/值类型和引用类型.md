## 值类型和引用类型
[[数据变量类型]]

#### 1.变量类型的复习

 ==无符号整形==

```c#
byte b = 1;
ushort us = 1;
uint ui = 1;
ulong ul = 1;
```

==有符号整形==

```c#
sbyte sb = 1;
short s = 1;
int i = 1;
long l = 1;
```

 ==浮点型==

```c#
float f = 1f;
double d = 1.1;
decimal de = 1.1m;
```

 ==特殊类型==

```c#
bool bo = true;
char c = 'a';
string str = "string";
```

==复杂数据类型==

```c#
enum 枚举
数组（一维 二维 交错）
```

把以上变量类型 分成 值类型和引用类型
==引用类型==:string,数组,类(没学
==值类型==:其他,结构体(没学

#### 2.值类型和引用类型的区别

使用上的区别

```c#
Console.WriteLine("值类型和引用类型的区别 值类型和引用类型的区别 值类型和引用类型的区别 值类型和引用类型的区别 值类型和引用类型的区别");
```

==值类型==

```c#
int a1 = 10;
```

==引用类型==

```c#
int[] arr1 = new int[] {1,2,3,4,5};
string str1 = "第一个";//特殊的引用类型（它变我不变
```

声明了一个b1让其等于之前的a1

```c#
cint b1 = a1;
```

声明了一个arr2让其等于之前的arr1

```c#
int[] arr2 = arr1;
```

声明了一个str2让其等于之前的str1

```c#
string str2 = str1;
Console.WriteLine("a={0} b={1}",a1,b1);c
Console.WriteLine("arr1[0]={0} arr2[0]={1}", arr1[0], arr2[0]);
Console.WriteLine("arr1={0} arr2={1}", str1, str2);
```

修改b1和arr2的值

```c#
Console.WriteLine();
b1 = 10086;
arr2[0] = 1145;
str2 = "第二个";
Console.WriteLine("修改b1和arr2后的值 修改b1和arr2后的值 修改b1和arr2后的值 修改b1和arr2后的值 修改b1和arr2后的值 修改b1和arr2后的值 ");
Console.WriteLine("a={0} b={1}", a1, b1);//修改后值不一样了
Console.WriteLine("arr1[0]={0} arr2[0]={1}", arr1[0], arr2[0]);//修改后两者的值都变成后面赋值的
Console.WriteLine("arr1={0} arr2={1}", str1, str2);
```

==值类型==：在**互相赋值**时 把内容拷贝给了对方 **它变我不变**
==引用类型==：<span id="值类型">在**相互赋值** 是让两者指向同一个值 **他变我也变**</span>

为什么有以上的区别

==值类型== 和 ==引用类型== 存储在的 内存区域 是不同的 **存储方式是不同**的
所以就造成了 他们使用上的区别



==值类型==存储在 **栈空间**--系统分配的空间，自动回收，内存小但速度快

<img src="笔记图片/栈与堆.jpg" align="left" style="margin-left: 0px; zoom: 67%;" />

==引用类型==存储在 **堆空间**--手动申请和释放，内存大但速度慢

<img src="笔记图片/引用类型赋值关系图.jpg" style="zoom: 67%; margin-left: 0px;" />

new 就等于开了一个新的空间 两者互不相干

```c#
arr2 = new int[] {99,2,3,5};
Console.WriteLine("arr1[0]={0} arr2[0]={1}", arr1[0], arr2[0]);
```





---
