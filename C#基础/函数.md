## 函数



### 基本<span id="函数">概念</span>

==函数== 也叫做 ==方法==
本质是一块**具有名称**的`代码块`
可以使用==函数==（方法）的**名称来执行**该代码块
函数（方法）是**封装代码**进行**重复使用**的一种机制
函数（方法）的**主要作用**：

> 1.封装代码
> 2.提升代码复用率（少些点代码）
> 3.抽象行为

==总结==
1.基本概念
2.函数写在哪里 --- `calss` 或 struct 中
3.基本语法  1  2  3  4  5
4.`return` 可以提前结束函数逻辑  (程序是线性执行的 **从上往下**

#### 函数写在哪里

>    1.`class`语句块中
>    2.`strucs`语句块中

#### 基本语法

```c#
1    2     3             4
static 返回类型 函数名(参数类型 参数名1,参数类型 参数名2,....)  //可以放无数个参数
{
 函数的代码逻辑;
 函数的代码逻辑;
 函数的代码逻辑;
 ...
   5
 return 返回值;  //如果有返回类型才返回

}
```

>1.关于`static` 它**不是必须**的 但在**没有**学习 `类` 和 `结构体`前 都是必须写的
>2.关于==返回类型== 新关键词 `void`(表示没有返回值)
>==返回类型== 可以写**任意**的**变量类型** 14种变量类型 + 复杂数据类型(数组 枚举 结构体 类)
>3.关于函数名 **自定义名称** 建议使用帕斯卡命名法(首字母大写)或驼峰命名法
>4.参数<u>不是必须</u>的 可以有**0~N个**参数类型可以是**任意类型** 14种变量类型 + 复杂数据类型(数组 枚举 结构体 类)
>参数名 **自定义** 建议使用帕斯卡命名或驼峰命名法
>5.当返回值类型**不为**`void`时 必须通过`return`返回对于类型的内容  (注意:即使是**void也可以使用return**)

#### 实际运用

```c#
//1/无参无返回值函数
1   2    3   4
static void Demo1()
{
	Console.WriteLine("Hello World");
  	  5 在没有返回值时 也就是返回值类型为void 可以省略
	return;
}

//2.有参无返回值函数
static void Demo2(string name)
{
	Console.WriteLine("你的名字是:{0}",name);
   	  5
	//return; 省略
}

//3.无参有返回值函数

1    2   3   4
static string Demo3()
{
	  5
	return "Xiao";
}

//4.有参有返回函数

1   2   3     4
static int Demo4(int a,int b)
{
	//int c = a+b;
	//return c;
	//  5  retrun后面可以写一个表达式 结果和返回值类型是一致的就行
	return a + b;
}

//5.有参有多返回值函数
//传入两个数 然后计算两个数的和 以及他们两的平均数 得出结果返回出来
//函数的返回 一定是一个类型 只能是一个内容
1   2   3     4
static int[] Demo5(int a,int b)
{
	int sum = a + b;
	int avg = sum / 2;
	//int[] arr = {sum,avg};
	//return arr;
	//一步到位:  5
	return new int[] {sum,avg};
//如果是用数组作为返回值出去 那么前提是 使用者 知道这个数组的规则
}
```

​    ==使用函数==

```c#
使用函数 直接 写函数名(参数) 即可

Demo1();
// 参数可以是 常量 变量 函数都可以
// 参数 一定是传一个 能够得到对应类型的表达式
string str = "XiaoYueYe";
//传入一个string变量
Demo2(str);
//传入一个string常量
Demo2("筱夜説");
//传入一个返回值是string的函数
Demo2(Demo3());
//有返回值的函数  要不是直接拿返回值来用
//就是拿变量 接收它的结果
string str2 = Demo3();
//也可以直接调用 但是 返回值 对我们来说就没有用了
Demo3();

Console.WriteLine(Demo4(2,5));

int[] arr = Demo5(5, 7);
Console.WriteLine(arr[0]+" " + arr[1]);

Demo6("SB");//关于return
```

#### 关于return

即使函数没有返回值 我们有可以使用`return`
`return` 可以直接不执行`return`之后的代码跳出函数

```c#
static void Demo6(string str)
{
    if (str == "SB")
      {
        return;
      }
      Console.WriteLine(str);
    }
    //或
static string Demo6_1(string str)
{
    if (str == "SB")
    {
		return "";
      }
		return(str);
    }
```

#### 练习题

##### 1.写一个函数,比较两个数字的大小,返回最大值

```c#
static int Demo1(int a, int b)
{
    //int max = 0;
    //if (a > b)
    //{
    //    max = a;
    //}
    //else
    //{
    //    max = b;
    //}
    //return max;
    if (a > b)
    {
        return a;//return 会直接跳出函数所以可以省略elst
    }
    return b;

    //三目运算符
    return a>b ? a:b;
}
```



##### 2.写一个函数 用于计算一个圆的面积和周长 并返回打印

```c#
static float[] Demo2(float r)
{
    //float PI = 3.1415926f;
    //float S = PI * (r * r);
    //float C = 2 * PI * r;
    //return new float[] { S, C };
    //老师的解法：
    float[] f = new float[2];
    f[0] = 3.14f * r * r;
    f[1] = 2 * 3.14f * r;
    return f;
    //一步到位
    return new float[] { 3.14f * r * r, 2 * 3.14f * r };

}
```



##### 3.写一个函数 求一个数组的总和 最大值 最小值 平均数

```c#
static void Demo3(int[] arr)
{
    if(arr.Length == 0)
    {
        Console.WriteLine("数组不能为空");
        return;
    }
    int max = arr[0];
    int min = arr[0];
    int sum = 0;
    int avg = 0;

    for (int i = 0; i < arr.Length; i++)
    {
        sum += arr[i];

        if (max < arr[i] )
        {
            max= arr[i];
        }
        if (min > arr[i])
        {
            min= arr[i];
        }
    }
    avg=sum/arr.Length;

    Console.WriteLine("最大值：{0} 最小值：{1} 总和：{2} 平均数：{3}",max,min,sum,avg);
}
```



##### 4.写一个函数,判断你传入的参数是不是质数 (质数：一个只能被1和自己整除的数)

```c#
 static bool Demo4(int num)
 {
     //判断质数的逻辑
     for(int i = 2; i < num; i++)
     {
         //得到从2到num-1之间的数
         if (num % i == 0)
         {
             //和循环配合使用 break continue
             return false;
         }
     }
     //默认认为他就是质数
     return true;
 }
```



##### 5.写一个函数,判断你输入的年份是否是闰年

```c#
static bool Demo5(int a)
{
    if (a % 400 == 0 || (a % 4 == 0 && a % 100 != 0))
    {
        return true;
    }

    //默认不是
    return false;
}
```



---



### ref和<span id="out">out</span>

#### 总结:

1.`ref`和`out`的作用:解决值类型和引用类型 在函数==内部== 改值 或者 **重新声明 能够影响外部传入**的变量 让其也被修改
2.使用上：就是在声明参数的时候 在**前面**加上 `ref`和`out`的关键词即可 使用上 同上
3.区别：
`ret`传入的变量==必须初始化== 但是在内部 **可改可不改**
`out`传入的变量**可以不用初始化** 但是在内部 ==必须修改值==

#### 学习ref和out的原因

他们可以解决 在函数**内部改变外部传入的内容** ==里面变了外面也要变==
`ref`和`out`的作用:解决**[值类型](#值类型)**和**[引用类型](#值类型)** 在函数内部进行 改值 或者 **重新声明 而能够影响外部传**入的变量 让其也被修改

```c#
//数组(值类型)
static void ChangeValue(int value)//传入a相当于在栈开了一个新的房间只在内部使用 跟外面的没有任何关系
{
    value = 3;
}

//数组(引用类型)
static void ChangeArrayValue(int[] arr)//将arr2堆的地址传到了这个
{
    arr[0] = 99;//把相同地址的堆里面的数改了 外面的数自然也就改了
}
//数组(引用类型) [但重新new一个]
static void ChangeArray(int[] arr)
{
    //new就是等于在堆里面重新开辟一个新的房间 地址不相同外面的自然也不会变
    arr = new int[] { 1, 2, 3 };
}
```



#### ref和out的使用

函数参数的==修饰符==
**当传入的值类型参数在内部修改时 或者引用类型参数在内部重新声明时**
外部的值**会发生变化**

```c#
//ref
static void ChangeValueRef (ref int value)//数值类型
{
    value = 99;
}

static void ChangeArrayRef(ref int[] arr)//引用类型
{
    arr = new int[] { 99,20,30 };
}

//out
static void ChangeValueOut(out int value)//数值类型
{
    //out 传入的变量必须在内部有进行赋值 ref不用
    value = 99;
}

static void ChangeArrayOut(out int[] arr)//引用类型
{
    arr = new int[] { 99, 20, 30 };
}
```

```c#
//(值类型)
int a = 1;
ChangeValue(a);//
Console.WriteLine(a);//输出1

//ret 
Console.WriteLine("ret后");
ChangeValueRef(ref a);
Console.WriteLine(a);//输出99

//out
Console.WriteLine("out后");
ChangeValueOut(out a);
Console.WriteLine(a);//输出99

//(引用类型)
int[] arr2 = {1,2,3};
ChangeArrayValue(arr2);
Console.WriteLine(arr2[0]);//输出99 

//(引用类型)[但重新new一个]
Console.WriteLine("new后");
arr2[0] = 1;
ChangeArray(arr2);
Console.WriteLine(arr2[0]);//输出1

//ref后
Console.WriteLine("new但ref后");
ChangeArrayRef(ref arr2);
Console.WriteLine(arr2[0]);//输出99

//ref后
Console.WriteLine("new但out后");
ChangeArrayOut(out arr2);
Console.WriteLine(arr2[0]);//输出99
```



#### ref和out的区别

`ref` 传入的变量**必须**先**初始化** `out`不用
`out` 传入的变量**必须在内部**有进行**赋值**  `ref`不用

`ret`传入的变量**必须初始化** 但是在内部 可改可不改
`out`传入的变量可以不用初始化 但是在**内部 必须修改值**



#### 练习题

##### 1.让用户输入用户名密码 返回应该bool类型的登录结果,而且还要返回单独的登录信息,如果用户名错误,除了返回登录结果自外,登录信息为“用户名错误”,如果密码错误,除了返回登录结果之外,登录信息为“密码错误”



```c#
static bool NamePwd(string name, string pwd , ref string info)
{
    string Myname = "xiao";
    string Mypwd = "123";
    
    if(name == Myname)
    {
        if (pwd == Mypwd)
        {
            info = "登录成功";
            return true;
        }
        else
        {
            info = "密码错误";
        }
    }
    else
    {
        info = "用户名错误";
    }
    return false;
}
```

```c#
Console.WriteLine("输入用户名");
string name = Console.ReadLine();
Console.WriteLine("输入密码");
string pwd = Console.ReadLine();
string inpo = "";
NamePwd(name, pwd,ref inpo);
while (!NamePwd(name, pwd, ref inpo))
{
    Console.WriteLine(inpo);
    Console.WriteLine("******************************");
    Console.WriteLine("输入用户名");
    name = Console.ReadLine();
    Console.WriteLine("输入密码");
    pwd = Console.ReadLine();
    
}
Console.WriteLine(inpo);
```



---



### 变长参数和参数默认值

#### 总结:

##### 一,变长参数关键词 params

==作用==:可以传入n个同类型的参数 **n可以是0**
注意:
1.`params`后面**必须是数组** 意味着只能是**同一类型**的**可变参数**
2.变长参数**只能有一个**
3.必须在所有参数**最后**写变长参数

##### 二,参数默认值(可选参数

==作用==:可以**给函数**的参数**默认值** 使用时可以不传参 **不传用默认值 传了就用传的**
注意:
1.可选参数**可以有多个**
2.可选参数**必须**写**在**正常参数的**后面**

#### 变长参数关键词

举例 函数要计算 n个整数的和

```c#
static int Sum（int a,int b,...){

}
```

使用变长参数关键词 `params`

```c#
static int Sum(params int[] arr)
{
    int sum = 0;
    for (int i = 0; i < arr.Length; i++)
    {
        sum += arr[i];
    }
    return sum;
}
```

```c#
Sum();
Sum(1,2,3,4);
```

`params int[] arr` 意味着**可以传入n个**int**参数** n可以等于0 传人的参数 会存在arr数组中
注意：
1.`params`关键词后面**必须为数组**
2.数组的类型**可以是任意的类型**

3.==函数参数==可以有 别的参数和`params`关键字修饰的参数
4.==函数参数==中**最多**只能出现**一个**`params`关键字 而且**一定**是**在最后一组参数** 它前面**可以写n个其他的参数**
4.列如:

```c#
static void cesi(string name,params string[] things)
{
        
}
```

#### 参数默认值

**有参数默认值**的参数 一般**称为可选参数**
==作用==:当**调用函数时可以不传人参数 不传就会使用默认值作为参数的值**
如:

```c#
static void Speak(string speak = "这个是默认参数")
{
    Console.WriteLine(speak);
}
```

```c#
//不传入则使用默认值
Speak();
Speak("123123132");
```

==注意:==
1.**支持多参数默认值** 每个参数**都可以有默认值**
2.如果要**混用** 可选参数 **必须写在 普通参数后面** (带默认值的必须卸载普通的后面 
如:

```c#
static void Speak2(string a,string b,string c = "默认值",string d = "可以有多个")
{

}
```

#### 练习

##### 第一题:使用param参数 求多个数字的和以及平均数

```c#
static void Age(params int[] args) 
{
    if (args.Length == 0)
    {
        Console.WriteLine("没有参数");
        return;
    }
    int sum = 0;
    for (int i = 0; i < args.Length; i++)
    {
        sum += args[i];
    }
    Console.WriteLine("总和:"+sum);
    Console.WriteLine("平均数:"+sum/args.Length);
}
```

##### 第二题:使用param参数 求多个数字的偶数和奇数和

```c#
static void Sum(params int[] args)
{
    if (args.Length == 0)
    {
        Console.WriteLine("没有参数");
        return;
    }
    int ONum = 0;
    int even = 0;
    for (int i = 0; i < args.Length; i++)
    {
        
        if (args[i]%2 != 0)
        {
            ONum += args[i];
        }
        else
        {
            even += args[i];
        }
    }
    Console.WriteLine("奇数和:" + ONum);
    Console.WriteLine("偶数和:" + even);
}
```



##### 输入

```c#
int[] arr = new int[5];
for (int i = 0;i < arr.Length;i++)
{
    Console.WriteLine("输入第{0}个数", i+1);
    int a = int.Parse(Console.ReadLine());
    arr[i]= a;
    Console.WriteLine();
}

Age(arr);
Sum(arr);
```



---



### 函数重载

#### 总结:

==概念==:**同一个**语句块中 **函数名相同** <u>参数**数量 类型 顺序 不同**的函数</u> 就称为我们的**重载函数**
注意:与返回值无关
==作用==:一般用来处理不同参数的同一类型的逻辑处理



#### 基本概念

==重载概念==
在**同一个语句块**(class或者struct)中
函数(方法)**名相同**
参数的**数量不同**
或者
参数的**数量相同**,但参数的**类型或顺序不同**

==作用==:
1.命名一组功能相似的函数 **减少函数名的数量 避免命名空间的污染**
2.**提升**程序的**可读性**

#### 实例

==注意:==
1.重载和**返回值的类型无关**,只和参数类型,个数,顺序有关
2.调用时 程序会自己**根据传入的参数**类型**自动判断使用哪一个重载**

```c#
static int Sum(int a,int b) 
{
 return a + b;
}
//参数数量不同
static int Sum(int a, int b , int c)
{
    return a + b + c;
}
//数量相同 类型不同
static float Sum(float a, float b)
{
    return a + b;
}
//数量相同 类型不同
static float Sum(int a, float f)
{
    return a + f;
}
//数量相同 顺序不同
static float Sum(float f, int a)
{
    return f + a;
}
```
#### ref和out

[跳转相关知识](#out)
`ref`和`out` 可以理解成 **他们也是一种变量类型** 所有可以用在重载中 但是`ref`和`out`**不能同时修饰**

```c#
static float Sum(ref float f,int a)
{
    return f+a;
}

//变长参数也可以用在重载中
static float Sum(int a, int b,params int[] c)
{
    return 1;
}
```

#### 练习题

重载一个函数
让其可以比较两个`int`或两个`float`或两个`double`的大小并返回较大的那个值

```c#
//int类型
static int Compare(params int[] arr)
{
    int max = arr[0];
    if (arr.Length==0)
    {
        Console.WriteLine("没有传入的参数");
        return 0;
    }
    for (int i = 0; i < arr.Length; i++)
    {
        //if (arr[i] > max)
        //{
        //    max = arr[i];
        //}
        max = arr[i]>max ? arr[i] : max;
    }

    Console.WriteLine("最大的数是:{0}",max);
    return max;
}
//float类型
static float Compare(params float[] arr)
{
    if (arr.Length == 0)
    {
        Console.WriteLine("没有传入的参数");
        return 0;
    }
    float max = arr[0];
    for (int i = 0; i < arr.Length; i++)
    {
        max = arr[i] > max ? arr[i] : max;
    }

    Console.WriteLine("最大的数是:{0}", max);
    return max;
}
//double类型
static double Compare(params double[] arr)
{
    if (arr.Length == 0)
    {
        Console.WriteLine("没有传入的参数");
        return 0;
    }
    double max = arr[0];
    for (int i = 0; i < arr.Length; i++)
    {
        max = arr[i] > max ? arr[i] : max;
    }
    Console.WriteLine("最大的数是:{0}", max);
    return max;
}
```

重载一个函数
让其可以比较n个`int`或n个`float`或n个`double`的大小并返回最大的那个值
(用`params`可变参数来完成)

```c#
//int类型
static int Compare(params int[] arr)
{
    int max = arr[0];
    if (arr.Length==0)
    {
        Console.WriteLine("没有传入的参数");
        return 0;
    }
    for (int i = 0; i < arr.Length; i++)
    {
        //if (arr[i] > max)
        //{
        //    max = arr[i];
        //}
        max = arr[i]>max ? arr[i] : max;
    }

    Console.WriteLine("最大的数是:{0}",max);
    return max;
}
//float类型
static float Compare(params float[] arr)
{
    if (arr.Length == 0)
    {
        Console.WriteLine("没有传入的参数");
        return 0;
    }
    float max = arr[0];
    for (int i = 0; i < arr.Length; i++)
    {
        max = arr[i] > max ? arr[i] : max;
    }

    Console.WriteLine("最大的数是:{0}", max);
    return max;
}
//double类型
static double Compare(params double[] arr)
{
    if (arr.Length == 0)
    {
        Console.WriteLine("没有传入的参数");
        return 0;
    }
    double max = arr[0];
    for (int i = 0; i < arr.Length; i++)
    {
        max = arr[i] > max ? arr[i] : max;
    }

    Console.WriteLine("最大的数是:{0}", max);
    return max;
}
```



---



### 递归函数

#### 基本概念

==**递归函数**== 就是 **让函数自己调用自己**
        

```c#
static void Fun()
{
    if (false)
    {
        return;
    }
    Fun();
}
```

<kbd>(上述代码为错误案例(没有结束))</kbd>

一个==正确==的**递归函数**
1.**必须有结束**调用的条件
2.**有**用于**条件判断的** 这个条件 **必须改变 能够达到停止的目的**

#### 实例

用递归函数打印出1到10
==递归函数== 就是 **让函数自己调用自己**

```c#
static void Fun(int a)
{
    //第四步:结束条件(终止递归)
    if (a > 10)
    {
        return;
    }
    //第二步:完成要求 打印
    Console.WriteLine(a);
    //第三步:完成一个 递归的变化 作为我们条件的判断
    a++;
    //第一步:构造一个递归
    Fun(a);
}
```

#### 练习题

##### 1.传入一个值 递归求该值的阶乘

并返回 如: 5! = 1 * 2 * 3 * 4 * 5
		  5! = 5 * 4 * 3 * 2 *1

```c#
static int Fun2(int i)
{
    if (i == 1)
    {
        return 1;
    }
    //return 5*4*3*2*1;
    return i * Fun2(i - 1);
    //5*Fun2(4) = 5*4*3*2*1;
    //4*Fun2(3) = 4*3*2*1;
    //3*Fun2(2) = 3*2*1;
    //2*Fun2(1) = 2*1;
    //1
}

Console.WriteLine(Fun2(6));
```

##### 2.使用递归求 1!+2!+3!+4!...+10!

结合 第二题

```c#
static int Fun3(int i)
{
    if (i == 1)
    {
        return Fun2(1);
        //return 1;
    }
    //10! + 9! + 8!...1!
    return Fun2(i) + Fun3(i - 1);
    //!10 + Fun3(9)
    //!9 + Fun3(8)
    //!8 + Fun3(7)
    //...
}

Console.WriteLine(Fun3(10));
```

##### 3.一根竹竿长100m 每天砍掉一半 求第十天它的长度是多少(从第0天开始)

```c#
static void Fun4( double l , int d = 0)//默认0天
{
    if (d > 10)
    {
        return;
    }
    Console.WriteLine("第{0}天 还剩{1}m", d, l);
    l /= 2;
    d++;
    Fun4(l, d);
}

Fun4(100);//100m d有默认值 所以可不填
```

##### 4.不允许使用循环语句 条件语句 在控制台中打印1~200这200个数(提示:递归+[短路](#短路))

```c#
static bool Fun5(int i = 1)
{
    Console.WriteLine(i);
    //if (i == 1)
    //{
    //    return false;
    //}
    return i >= 200 || Fun5(i+1);//有真则真 当前面的i>=200为真时 则 不执行后面的Fun5 
}
```



---