## 什么是程序集
程序集是经由编译器得到的 提供一般编译执行的那个中间产物
在windows系统中 它一般表现为后缀为.dll(库文件) 或者是.exe(可执行文件)的格式

说人话:
程序集就是我们写的一个代码合集 我们现在写的所有代码
最终都会被编译器翻译为一个程序集供别人使用
比如一个代码库文件(.dll)或者一个可执行文件(.exe)

## 元数据
元数据就是用来描述数据的数据
这个概念不仅仅用于程序上 在别的领域也有元数据

说人话:
程序中的类,类中的函数,变量等等信息就是 程序的 元数据
有关程序以及类型的数据被称为 元数据,它们保存在数据集中

## 反射的概念
程序正在运行时 可以查看其他程序集或者自身的元数据
==一个运行的程序查看本身或者其他程序的元数据的行为就叫做反射==

说人话:
在程序运行时 **通过反射可得到其他程序集**或者自己程序集代码**的各个信息**
类,函数,变量,对象等等,实例化它们,执行它们,**操作它们**

### 反射的作用

因为反射可以在程序编译后获取信息 所以它**提高了程序的扩展性和灵活性**
1.程序运行时得到所有元数据 包括元数据的特性
2.程序**运行时 实例化对象 操作对象**
3.程序**运行时创建新对象 用这些对象执行任务**

## 语法相关

### Type
`Type`(类的信息类)
它是反射功能的基础
它是访问元数据的==**主要方式**==
使用 `Type` 的成员获取有关类型声明的信息
有关类型的成员(如构造函数 方法 字段 属性和类的事件)

#### 获取Type
1.万物之父`object`中的 `GetType()`可以获取对象的`Type`
```C#
int a = 42;
Type type =a.GetType();
Console.WriteLine(type);
```

2.通过`typeof`关键词 传入类名 要可以得到对象的`type`
```C#
Type type2 =typeof(int);
Console.WriteLine(type2);
```

3.通过类的名字 也可以获取类型
注意:类名必须包含命名空间 不然找不到
```C#
Type type3 = Type.GetType("System.Int32");
Console.WriteLine(type3);
```


#### 得到类的程序集信息
可以通过Type可以得到类型所在的程序集信息
```C#
Console.WriteLine(type.Assembly);
Console.WriteLine(type2.Assembly);
Console.WriteLine(type3.Assembly);
```

#### 获取类的所以公共成员
```C#
class Test
{
    private int i = 1;
    public int j = 0;
    public string str = "1231";
    public Test()
    {

    }
    public Test(int i)
    {
        this.i = i;
    }
    public Test(int i, string str) : this(i)
    {
        this.str = str;
    }

    public void Speak()
    {
        Console.WriteLine(i);
    }
}
```

```C#
//首先得到Type
Type t = typeof(Test);
//然后得到所有公共成员
//需要引用命名空间 using System.Reflection;
MemberInfo[] infos = t.GetMembers();
for (int i = 0; i < infos.Length; i++)
{
    Console.WriteLine(infos[i]);
}
```

##### 获取类的公共构造函数并调用
```C#
//1.获取所有构造函数
ConstructorInfo[] ctors = t.GetConstructors();
for (int i = 0; i < ctors.Length; i++)
{
    Console.WriteLine(ctors[i]);
}
//2.获取其中一个构造函数 并执行
//GetConstructor得到构造函数传入 Type数组 数组中内容按顺序是参数类型的
//Invoke执行构造函数传入 object数组 表示按顺序传入的参数
//2-1.得到无参构造 (无参传0代表没有)
ConstructorInfo info = t.GetConstructor(new Type[0]);
//执行无参构造 无参构造 没有参数 传null
Test obj = info.Invoke(null) as Test;
Console.WriteLine(obj.j);
//2-2.得到有参构造
ConstructorInfo info2 = t.GetConstructor(new Type[] {typeof(int)});
obj = info2.Invoke(new object[]{2}) as Test;
Console.WriteLine(obj.str);
//多参数
ConstructorInfo info3 = t.GetConstructor(new Type[] {typeof(int),typeof(string)});
obj = info3.Invoke(new object[] {4,"字符串"}) as Test;
Console.WriteLine(obj.str);
```

##### 获取类的公共成员变量
```C#
//1.得到所有成员变量
FieldInfo[] fieldInfos = t.GetFields();
for (int i = 0; i < fieldInfos.Length; i++)
{
    Console.WriteLine(fieldInfos[i]);
}
//2.得到指定名称的公共成员变量
FieldInfo infoJ = t.GetField("j");
Console.WriteLine(infoJ);
//3.通过反射获取和设置对象的值
Test test = new Test();
test.j = 10086;
test.str = "Hello";
//3-1.通过反射 获取对象的某个变量的值
Console.WriteLine(infoJ.GetValue(obj));
Console.WriteLine(infoJ.GetValue(test));
//3-2.通过反射 设置指定对象的某个变量的值 (变量名,修改的值)
infoJ.SetValue(test, 100);
Console.WriteLine(infoJ.GetValue(test));
```

##### 获取类的公共成员方法
```C#
//通过Type类中的 GetMethod方法 得到类中的方法
//MethodInfo 是方法的反射信息
Type strType = typeof(string);

//1.如果存在方法重载 用Type数组表示参数类型
MethodInfo[] methods = strType.GetMethods();
for (int i = 0; i < methods.Length; i++)
{
    Console.WriteLine(methods[i]);
}

//单独获取对象的方法                    (第一个参数是方法名,第二个是重载参数类型)
MethodInfo subStr = strType.GetMethod("Substring",new Type[] {typeof(int),typeof(int)});

//2.调用该方法
//注意:如果是静态方法 Invoke中的第一个参数传null即可
string str = "Hello World!!";
//(第一个参数 相当于 是哪个对象要执行这个成员方法 , 第二个是要传入的值)
object result = subStr.Invoke(str,new object[] {7,5});
Console.WriteLine(result);
```

##### 获取其他
`Type`;
得枚举
`GetEnumName`
`GetEnumNames`

得事件
`GetEvent`
`GetEvents`

得接口
`GetInterface`
`GetInterfaces`

得属性
`GetProperty`
`GetPropertyss`

等等

### Activator
用于快速实例化对象的类
用于将`Type`对象**快捷实例化为对象**
先得到`Type`
然后 快速实例化一个对象
```C#
Type testType = typeof(Test);
```
1.无参构造
```C#
Test testObj = Activator.CreateInstance(testType) as Test;
Console.WriteLine(testObj.str);
```
2,有参构造
```C#
testObj = Activator.CreateInstance(testType, 2) as Test;
Console.WriteLine(testObj.j);

testObj = Activator.CreateInstance(testType, 5, "Hello") as Test;
Console.WriteLine(testObj.str);
```

## 总结
反射
在程序运行时,通过反射可以得到其他程序集或者自己的程序集代码的各种信息
类,函数,变量,对象等等 实例化它们 执行它们 操作它们

关键类
`Type`
`Assembly`
`Activator`

对于我们的意义
在初中级阶段 基本不会使用反射
所以目前对于大家来说 了解反射可以做什么就行
很长时间内都不会用到反射相关知识点

为什么要学反射
为了之后学习Unity引擎的基本工作原理做铺垫
Unity引起的基本工作机制 就是建在反射的基础上

---
## 练习
新建一个类库工程
有一个Player类,有姓名,血量,攻击力,防御力,位置信息等
有一个无参构造函数
在新建一个控制台工程
通过反射的形式使用类库工程生产的dll程序集
实例化一个Player对象
```C#
namespace lesson20_反射_练习_类库


    public struct Position
    {
        public int x;
        public int y;
        public Position(int x, int y)
        {
            this.x = x;
            this.y = y;
        }
    }
    class Player
    {
        public string name;
        public int hp;
        public int atk;
        public int def;
        public Position pos;
    }
}
```

```C#
//加载类库生成的 程序集 dll库文件
Assembly assembly = Assembly.LoadFrom("E:\\VS项目\\C#进阶教程\\lesson20_反射_练习_类库\\bin\\Debug\\lesson20_反射_练习_类库");
Type[] types = assembly.GetTypes();
for (int i = 0; i < types.Length; i++)
{
    Console.WriteLine(types[i]);
}

Type player = assembly.GetType("lesson20_反射_练习_类库.Player");
//快速实例化对象的类
object obj = Activator.CreateInstance(player);
```