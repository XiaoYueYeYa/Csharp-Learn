## 特性是什么
特性是一种**允许**我们**向程序集添加元数据**的语言结构
它是用于保持程序结构信息的某种特殊类型的类

特性提供功能强大的方法以将声明信息与 C#代码(类型 方法 属性)进行关联
特性与程序实体关联后 即可在运行时使用反射查询特性信息

特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中
它可以放置在任何几乎所有的声明中(类 变量 函数 等等声明)

说人话:
特性**本质是个类**
我们可以利用特性类**为元数据添加额外信息**
==比如一个类 成员变量 成员方法等等为它们添加更多的额外信息==
**之后可以通过反射来获取这些额外信息**

### 自定义特性
继承特性基类 Attribute
```C#
class MyCustomAttribute : Attribute
{
    //特性中的成员 一般根据需求来写
    public string info;
    public MyCustomAttribute(string info)
    {
        this.info = info;
    }
    public void testFun()
    {
        Console.WriteLine("特性的方法");
    }
}
```

### 特性的使用
基本语法:
```C#
[特性名(参数列表)]
```
本质上 就是在调用特性类的构造函数
写在哪里?
类 函数 变量的上一行,表示TM具有该特性信息 如下

特性名会自动隐藏`Attribute`
```C#
[MyCustom("这个一个用于计算的类")]
[MyCustom("这个一个用于计算的类")]
class MyClass
{
    [MyCustom("这个一个成员变量")]
    public int value;

    //[MyCustom("这个一个用于计算加法的函数")]
    //public void TestFun([MyCustom("函数参数")]int a)
    //{
    
    //}
    public void TestFun(int a)
    {
    
    }
}
```

```C#
MyClass mc = new MyClass();
Type t = mc.GetType();
//Type t = typeof(MyClass);
//Type t = Type.GetType("lesson21_特性.MyClass");

//判断是否使用了某个特性
//IsDefined(参数一, 参数二)
//参数一:特性的类型
//参数二:代表是否搜索继承链(属性和事件忽略此参数)
if (t.IsDefined(typeof(MyCustomAttribute), false))
{
    Console.WriteLine("该类型引用了MyCustom特性");
}

//获取Type元数据中的所有特性
object[] array = t.GetCustomAttributes(true);
for (int i = 0; i < array.Length; i++)
{
    if (array[i] is MyCustomAttribute)
    {
        Console.WriteLine((array[i] as MyCustomAttribute).info);
        (array[i] as MyCustomAttribute).testFun();
    }
}
```

### 限制自定义特性的使用范围
通过特性类 加特性 限制其使用范围
```C#
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct,AllowMultiple =true,Inherited =true)]
```
参数一:`AttributeTargets`  特性那个用在那些地方
参数二:`AllowMultiple`  是否允许多个特性实例用在同一个目标上
参数三:`Inherited`  特性是否能被派生类和重写成员继承
```C#
public class MyCustom2Attribute : Attribute
{

}
```

### 系统自带特性 - 过时特性
过时特性
`Obsolete`
用于提示用户 使用的方法等成员已经过时时 建议使用新的方法
一般加在函数前的特性

```C#
class TestClass
{
    //参数一:调用过时方法时 提示的内容
    //参数二:true使用该方法时会报错 false使用该方法时会警告
    [Obsolete("该方法已经过时了 请使用Speak方法",false)]
    public void OldSpeak(string str)
    {

    }
    public void Speak(string str)
    {

    }

}
```

```C#
TestClass testClass = new TestClass();
testClass.OldSpeak("123");//带警告
```

### 系统自带特性 - 调用者信息特性
哪个文件调用?
`CallerFilePath`特性
哪一行调用?
`CallerLineNumber`特性
哪个函数调用?
`CallerMemberName`特性

需要引用命名空间 
```C#
using System.Runtime.CompilerServices;
```
一般作为函数参数的特性
```C#

        public void SpeakCaller(string str,[CallerFilePath] string fileName = "",
            [CallerLineNumber]int line = 0,[CallerMemberName]string target="")
        {
            Console.WriteLine(str);
            Console.WriteLine(fileName);
            Console.WriteLine(line);
            Console.WriteLine(target);
        }
```

```C#
testClass.SpeakCaller("知识点六");
```

### 系统自带特性 - 条件编译特性
条件编译特性
`Condittional`
它会和预处理器指令 \#define配合使用

需要引用命名空间using System.Diagnostics;
主要可以用在一些调试代码上
有时想执行有时不想执行的代码
```
#define Fun
```



