## 特性是什么
特性是一种**允许**我们**向程序集添加元数据**的语言结构
它是用于保持程序结构信息的某种特殊类型的类

特性提供功能强大的方法以将声明信息与 C#代码(类型 方法 属性)进行关联
特性与程序实体关联后 即可在运行时使用反射查询特性信息

特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中
它可以放置在任何几乎所有的声明中(类 变量 函数 等等声明)

说人话:
特性**本质是个类**
我们可以利用特性类**为元数据添加额外信息**
==比如一个类 成员变量 成员方法等等为它们添加更多的额外信息==
**之后可以通过反射来获取这些额外信息**

### 自定义特性
继承特性基类 Attribute
```C#
class MyCustomAttribute : Attribute
{
    //特性中的成员 一般根据需求来写
    public string info;
    public MyCustomAttribute(string info)
    {
        this.info = info;
    }
    public void testFun()
    {
        Console.WriteLine("特性的方法");
    }
}
```

### 特性的使用
基本语法:
```C#
[特性名(参数列表)]
```
本质上 就是在调用特性类的构造函数
写在哪里?
类 函数 变量的上一行,表示TM具有该特性信息 如下

特性名会自动隐藏`Attribute`
```C#
[MyCustom("这个一个用于计算的类")]
[MyCustom("这个一个用于计算的类")]
class MyClass
{
    [MyCustom("这个一个成员变量")]
    public int value;

    //[MyCustom("这个一个用于计算加法的函数")]
    //public void TestFun([MyCustom("函数参数")]int a)
    //{
    
    //}
    public void TestFun(int a)
    {
    
    }
}
```

```C#
MyClass mc = new MyClass();
Type t = mc.GetType();
//Type t = typeof(MyClass);
//Type t = Type.GetType("lesson21_特性.MyClass");

//判断是否使用了某个特性
//IsDefined(参数一, 参数二)
//参数一:特性的类型
//参数二:代表是否搜索继承链(属性和事件忽略此参数)
if (t.IsDefined(typeof(MyCustomAttribute), false))
{
    Console.WriteLine("该类型引用了MyCustom特性");
}

//获取Type元数据中的所有特性
object[] array = t.GetCustomAttributes(true);
for (int i = 0; i < array.Length; i++)
{
    if (array[i] is MyCustomAttribute)
    {
        Console.WriteLine((array[i] as MyCustomAttribute).info);
        (array[i] as MyCustomAttribute).testFun();
    }
}
```

### 限制自定义特性的使用范围
通过特性类 加特性 限制其使用范围
```C#
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct,AllowMultiple =true,Inherited =true)]
```
参数一:`AttributeTargets`  特性那个用在那些地方
参数二:`AllowMultiple`  是否允许多个特性实例用在同一个目标上
参数三:`Inherited`  特性是否能被派生类和重写成员继承
```C#
public class MyCustom2Attribute : Attribute
{

}
```

### 系统自带特性 - 过时特性
过时特性
`Obsolete`
用于提示用户 使用的方法等成员已经过时时 建议使用新的方法
一般加在函数前的特性

```C#
class TestClass
{
    //参数一:调用过时方法时 提示的内容
    //参数二:true使用该方法时会报错 false使用该方法时会警告
    [Obsolete("该方法已经过时了 请使用Speak方法",false)]
    public void OldSpeak(string str)
    {

    }
    public void Speak(string str)
    {

    }

}
```

```C#
TestClass testClass = new TestClass();
testClass.OldSpeak("123");//带警告
```

### 系统自带特性 - 调用者信息特性
哪个文件调用?
`CallerFilePath`特性
哪一行调用?
`CallerLineNumber`特性
哪个函数调用?
`CallerMemberName`特性

需要引用命名空间 
```C#
using System.Runtime.CompilerServices;
```
一般作为函数参数的特性
```C#

        public void SpeakCaller(string str,[CallerFilePath] string fileName = "",
            [CallerLineNumber]int line = 0,[CallerMemberName]string target="")
        {
            Console.WriteLine(str);
            Console.WriteLine(fileName);
            Console.WriteLine(line);
            Console.WriteLine(target);
        }
```

```C#
testClass.SpeakCaller("知识点六");
```

### 系统自带特性 - 条件编译特性
条件编译特性
`Condittional`
它会和预处理器指令 \#define配合使用

需要引用命名空间
```c#
using System.Diagnostics;
```
主要可以用在一些调试代码上
有时想执行有时不想执行的代码
```c#
[Conditional("Fun")]
static void Fun()
{
    Console.WriteLine("Fun执行");
}
```

### 系统自带特性 - 外部dll包函数特性

`DllImport`
 
用来标记非.Net(C#)的函数 表明该函数在一个外部的DLL中定义
一般用来调用 C或者C++的Dll包写好的方法
需要引用命名空间 
```c#
using System.Runtime.InteropServices
```

```c#
[DllImport("Test.dll")]
public static extern int Add(int a, int b);
```

## 总结:
特性是用于 为元数据在添加更多的额外信息(变量 方法等等)
我们可以通过反射获取这些额外的数据 来进行一些特殊处理
自定义特性 继承`Attribute`类

系统自带特性:过时特性

为什么要学习特性
Unity引擎中很多地方都有用到了特性来进行一些特殊处理

---

## 练习

为反射练习题中的Plater对象中的
随便为其中一个成员变量加一个自定义特性
同样实现反射练习题中的要求
但是当在设置了自定义特性的成员变量时 在控制台中打印一句
非法操作 随意修改XXX成员
```C#
namespace lesson20_反射_练习_类库
{
    //lesson21_特性_练习
    //为反射练习题中的Plater对象中的
    //随便为其中一个成员变量加一个自定义特性
    //同样实现反射练习题中的要求
    //但是当在设置了自定义特性的成员变量时 在控制台中打印一句
    //非法操作 随意修改XXX成员
    //结构体位置信息
    class MyCustomAttribute : Attribute
    {
        
    }

    public struct Position
    {
        public int x;
        public int y;
        public Position(int x, int y)
        {
            this.x = x;
            this.y = y;
        }
    }
    class Player
    {
        [MyCustomAttribute()]
        public string name;
        public int hp;
        public int atk;
        public int def;
        public Position pos;
    }
}

```

```C#
Console.WriteLine("lesson21_特性_练习");
//为反射练习题中的Plater对象中的
//随便为其中一个成员变量加一个自定义特性
//同样实现反射练习题中的要求
//但是当在设置了自定义特性的成员变量时 在控制台中打印一句
//非法操作 随意修改XXX成员

Assembly assembly = Assembly.LoadFrom("E:\\VS项目\\C#进阶教程\\lesson20_反射_练习_类库\\bin\\Debug\\lesson20_反射_练习_类库");
Type[] types = assembly.GetTypes();
for (int i = 0; i < types.Length; i++)
{
    Console.WriteLine(types[i]);
}
//得Type
Type playerType = assembly.GetType("lesson20_反射_练习_类库.Player");
//实例化
object playerObj = Activator.CreateInstance(playerType);
Console.WriteLine(playerObj);


FieldInfo[] fields = playerType.GetFields();
for (int i = 0; i < fields.Length; i++)
{
    Console.WriteLine(fields[i]);
}


//首先要得到我们自定义特性的Type
Type attribute =assembly.GetType("lesson20_反射_练习_类库.MyCustomAttribute");

//赋值名字
FieldInfo fieldName = playerType.GetField("name");
//得到的特性如果不稳空 就证明有
if(fieldName.GetCustomAttribute(attribute) != null)
{
    Console.WriteLine("非法操作,随意修改name成员");
}
else
{
    //检测是否被自定义特性修饰 如果是 就不能修改 而是提示
    fieldName.SetValue(playerObj, "123");
    Console.WriteLine(fieldName.GetValue(playerObj));
}
```