## 委托是什么
委托是 `函数(方法)`的容器
可以理解为表示函数(方法)的变量类型
用来 **存储** 传递**函数(方法)**
委托的**本质是一个类** 用来定义函数(方法)的类型 (返回值和参数的类型)
不同的 函数(方法)必须对应和各自"格式"一致的委托

### 基本语法
关键字:`delegate`
语法:访问修饰符 `delegate` 返回值 委托名(参数列表);

写在哪里?
可以声明在`namespace`和`class`语句块中
更多是写在`namespace`中

简单记忆委托语法 就是 函数声明语法前面加一个`delegate`关键字

### 定义自定义委托
访问修饰符**默认**不写 为`public` 在别的命名空间中也能使用
`private` 其他命名空间就不能使用了
一般使用`public`
**声明**一个可以用来**存储**无参无返回值**函数的容器**
这个只是定义了规则 并没有使用
```C#
delegate void MyFun();
```
委托规则的声明 是**不能重名**的(在**同一语句块中**)
表示用来装载或传递 返回值为`int` 有一个`int`参数的函数的 委托 容器规则
```C#
delegate int MyFun2(int a);
```
委托是支持 泛型的 可以让返回值和参数 可变 更方便我们使用
```C#
delegate T MyFun3<T>(T v);
```

### 使用定义好的委托
==**委托变量是函数的容器**==

委托常用在:
1.作为类的成员
2.作为函数的参数

```C#

 static void Fun()
 {
     Console.WriteLine("无参无返回1");
 }

 static int Fun2(int a) 
 {
     return a;
 }
```

```C#
class Test
{
    public MyFun fun;
    public MyFun2 fun2;

    public void TestFun(MyFun fun,MyFun2 fun2)
    {
        //先处理一下别的逻辑 当这些逻辑1执行完了 在去执行传入的函数
        //延迟执行
        int i = 1;
        i += 2;
        i *= 3;

        fun();
        fun2(i);
        //或者先存入
        this.fun = fun;
        this.fun2 = fun2;
    }

    #region 增
    public void AddFun(MyFun fun,MyFun2 fun2)
    {
        this.fun += fun;
        this.fun2 += fun2;
    }
    #endregion
    #region 删
    public void RemoveFun(MyFun fun,MyFun2 fun2)
    {
        //this.fun = this.fun - fun
        this.fun -= fun;
        this.fun2 -= fun2;
    }
    #endregion

}
```

### 委托变量可以存储多个函数(多播委托)
如上面的:
1.增
2.删
```C#
//如何用委托存储多个函数
MyFun ff = null;
//ff = ff + Fun;
ff += Fun;
ff += Fun3;
ff();
//从容器中移除指定的函数
ff -= Fun;
//多减 不会报错 无非就是不处理
ff -= Fun;
ff -= Fun;
//清空容器
ff = null;
//如果为空直接执行会报错
if (ff != null)
{
    ff();
}
```


### 系统定义好的委托
自定义方法
```C#
static void Fun3()
{
    Console.WriteLine("无参无返回2");
}

static int Fun4() 
{
    return 1;
}
static string Fun5() 
{
    return "";
}
static void Fun6(int a,string b) 
{

}
static string Fun7(int a,int b) 
{

    return "";
}
```
系统定义好的委托
```C#
//使用系统自带委托 需要引用using System
//无参无返回
Action action = Fun;
action += Fun3;
action();

//可以指定返回值类型的 泛型委托
//无参有返回
Func<int> funcInt = Fun4;
Func<string> funcStr = Fun5;

//可以传n个参数的 系统提供了 1到16个参数的委托 直接用就行
//无返回值<参数类型, 参数类型,...>
Action<int,string> action1 = Fun6;

//可以传n个参数的 并且有返回值的 系统也提供了 16个委托
//<参数类型, 参数类型,....,返回类型>
Func<int, int, string> func = Fun7;
```

## 总结
简单理解 **委托** **就是装载** 传递**函数的容器**而已
可以用委托变量 来存储函数或者传递函数的
辞退其实已经提供了很多委托给我们使用
`Action`:没有返回值 参数提供了 0~16个委托给我们使用
`Func`:有返回值 参数提供了 0~16个委托给我们使用

---

## 练习
### 第一题
一家三口 妈妈做饭 爸爸妈妈和孩子都要吃饭
用委托模拟做饭--->开饭--->吃饭的过程
```C#
abstract class Person
{
    public abstract void Eat();
}
class Mother : Person
{
    public Action beginEat;
    public override void Eat()
    {
        Console.WriteLine("妈妈吃饭");
    }
    public void DoFood()
    {
        Console.WriteLine("妈妈做饭");

        Console.WriteLine("做好饭 开饭");

        //执行委托函数
        if (beginEat != null)
        {
            beginEat();
        }

    }
}
class Father : Person
{
    public override void Eat()
    {
        Console.WriteLine("爸爸吃饭");
    }
}
class Son : Person
{
    public override void Eat()
    {
        Console.WriteLine("孩子吃饭");
    }
}
```

```C#
Mother m = new Mother();
Father f = new Father();
Son s = new Son();
//告诉妈妈做好饭 要吃
m.beginEat += f.Eat;
m.beginEat += s.Eat;
m.beginEat += m.Eat;
//做饭
m.DoFood();
```

### 第二题
怪物死亡后 玩家要加10块钱 界面要更新数据 成就要累加怪物击杀数
请用委托来模拟实现这些功能 只用写核心逻辑表现这个过程
```C#
class Monster
{
    //当怪物死亡 把自己作为参数传出去
    public Action<Monster> deadDoSomthing;
    //怪物价格
    private int money = 10;
    public int Money
    {
        get {return money;}
    }
    public void Dead()
    {
        Console.WriteLine(deadDoSomthing != null?"当前怪物死亡": "当前怪物已经死亡了");
        if (deadDoSomthing != null)
        {
            deadDoSomthing(this);
        }
        //一般情况下 委托关联的函数 有加就有减(或者直接清空)
        deadDoSomthing = null;
    }
}
class Player
{
    private int myMoney = 0;
    public void MonsterDeadDoSomthing(Monster monster)
    {
        myMoney += monster.Money;
        Console.WriteLine("当前有{0}元",myMoney);
    }
}
class Panel
{
    private int nowSgowMoney = 0;
    public void MonsterDeadDoSomthing(Monster monster)
    {
        nowSgowMoney += monster.Money;
        Console.WriteLine("当前面板显示{0}元", nowSgowMoney);
    }
}
class Cj
{
    private int nowKillMonsterNum = 0;
    public void MonsterDeadDoSomthing(Monster monster)
    {
        nowKillMonsterNum += 1;
        Console.WriteLine("当前击杀了{0}个怪物", nowKillMonsterNum);
    }
}
```

```C#
Monster monster = new Monster();    
Player player = new Player();
Panel panel = new Panel();
Cj cj = new Cj();

monster.deadDoSomthing += player.MonsterDeadDoSomthing;
monster.deadDoSomthing += panel.MonsterDeadDoSomthing;
monster.deadDoSomthing += cj.MonsterDeadDoSomthing;
monster.Dead();
//一个怪物只能死一个
monster.Dead();

Monster monster2 = new Monster();
monster2.deadDoSomthing += player.MonsterDeadDoSomthing;
monster2.deadDoSomthing += panel.MonsterDeadDoSomthing;
monster2.deadDoSomthing += cj.MonsterDeadDoSomthing;
monster2.Dead();
```
