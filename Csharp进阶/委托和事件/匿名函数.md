## 什么是匿名函数
顾名思义 就是没有名字的函数
**匿名函数**的使用主要**是配合委托和事件进行使用的**
脱离委托和事件 是不会使用匿名函数的

### 基本语法
```C#
delegate (参数列表)
{
    //函数逻辑
};
```
何时使用?
1.函数中传递委托参数时
2.委托或事件赋值时

### 使用
1.无参无返回
这样声明匿名函数 只是在声明匿名函数 还没有调用
真正调用它的时候 是这个委托容器啥时候调用 就什么时候调用这个匿名函数

```C#
Action a  = delegate ()
{
    Console.WriteLine("123");
};
a();
```

2.有参无返回
```C#
Action<int, string> b = delegate (int a, string b)
{
    Console.WriteLine(a);
    Console.WriteLine(b);
};
b(1, "123");
```
3.有参有返回
```C#
Func<string> c = delegate ()
{
    return "123";
};
Console.WriteLine(c());
```
4.一般情况会作为函数参数传递 或者 作为函数返回值
```C#
class Test
{
    public Action action;
    //作为参数传递时
    public void Dosomthing(int a, Action fun)
    {
        Console.WriteLine(a);
        fun();
    }
    //作为返回值
    public Action GetFun()
    {
        return delegate(){
            Console.WriteLine("函数内部返回的一个匿名函数逻辑");
        };
    }
}
```

```C#
Test t = new Test();
Action ac = delegate ()
{
    Console.WriteLine("随参数传入的匿名函数逻辑");
};
// 参数传递
t.Dosomthing(50, ac);
t.Dosomthing(50, delegate ()
{
    Console.WriteLine("随参数传入的匿名函数逻辑");
});
//返回值
Action ac2 = t.GetFun();
ac2();
//一步到位 直接调用返回的 委托函数
//因为返回的是Action 所以可以直接调用
t.GetFun()();
```

### 匿名函数的缺点

添加到委托或事件容器中后 不记录 **无法单独移除**
```C#
Action ac3 = delegate ()
{
    Console.WriteLine("匿名函数一");
};
ac3 += delegate ()
{
    Console.WriteLine("匿名函数二");
};
ac3();
```
因为匿名函数没有名字 所以没有办法指定移除某一个匿名函数
此匿名函数 非彼匿名函数 不能通过看逻辑是否一样 就证明是同一个
```C#
ac3 -= delegate ()
{
    Console.WriteLine("匿名函数二");
};
ac3();
```
**只能通过null清空后 重新添加**
```C#
ac3 = null;
ac3 += delegate ()
{
    Console.WriteLine("匿名函数一");
};
ac3();
```

## 总结
匿名函数 就是没有名字的函数
固定写法
`delegate(参数列表){}`
主要是在 委托传递和存储时 为了方便可以直接使用匿名函数
缺点:没有办法指定移除

---

## 练习
写一个函数传入一个整数 返回一个函数
之后执行这个匿名函数时传入一个整数和之前那个函数传入的数相乘
返回结果

```C#
class Test
{
    public Func<int,int> AddFunc(int a)
    {
        //这中写法会改变 i的生命周期
        return delegate (int v)
        {
            return a * v;
        };
    }
}
```

```C#
Test t = new Test();

Func<int, int> fun = t.AddFunc(2);
//fun(4);
Console.WriteLine(fun(5));
```