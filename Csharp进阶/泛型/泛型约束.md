## 什么是泛型约束

==**让泛型的类型有一定的限制**==
关键字:`where`
泛型约束一个有**6种**
1.值类型                         `where` 泛型字母:`struct`
2.引用类型                       `where` 泛型字母:`class`
3.存在无参公共构造函数             `where` 泛型字母:`new()`
4.某个类本身或者其派生类           `where` 泛型字母:类名
5.某个接口的派生类型               `where` 泛型字母:接口名
6.另一个泛型类型本身或者派生类型     `where` 泛型字母:另一个泛型字母

`where` 泛型字母:(**约束的类型**)

### 各泛型约束讲解

#### 值类型约束
```C#
class Test1<T> where T : struct
{
    public T value;
    public void TestFun<K>(K k) where K : struct
    {

    }
}
```

```C#
//值类型约束
Test1<int> t1 = new Test1<int>();
t1.TestFun<float>(1.1f);
```

#### 引用类型约束
```C#
class Test2<T> where T : class
{
    public T value;
    public void TestFun<K>(K k) where K : class
    {

    }
}
```

```C#
//引用类型约束
Test2<Random> t2 = new Test2<Random>();
t2.value = new Random();
t2.TestFun<object>(new object());
```

#### 公共无参构造约束
```C#
class Test3<T> where T : new()
{
    public T value;
    public void TestFun<K>(K k) where K : new()
    {

    }
}
class Test1
{

}
class Test2
{
    public Test2(int a)
    {

    }
}
```

```C#
//公共无参构造约束
Test3<Test1> t3 = new Test3<Test1>();
//Test3<Test2> tt3 = new Test3<Test1>();
```

#### 类约束
```C#
class Test4<T> where T : Test1
{
    public T value;
    public void TestFun<K>(K k) where K : Test1
    {

    }
}
class Test3:Test1
{

}
```

```C#
//类约束
Test4<Test3> t4 = new Test4<Test3>();
```

#### 接口约束
```C#
interface IFly
{

}
class Test4 : IFly
{

}
class Test5<T> where T : IFly
{
    public T value;
    public void TestFun<K>(K k) where K : IFly
    {

    }
}
```

```C#
Test5<IFly> t5 = new Test5<IFly>();
```

#### 另一个泛型约束
```C#
class Test6<T,U> where T : U
{
    public T value;
}
```

```C#
//另一个泛型约束
Test6<Test4,IFly> t6 = new Test6<Test4,IFly>();
```

### 约束的组合使用
逗号分隔
```C#
class Test7<T> where T : class, new()
{

}
```

### 多个泛型有约束
```C#
class Test8<T,K> where T:class,new() where K : struct
{

}
```

### 总结

泛型约束:让类型有一定限制
`class`
`struct`
`new()`
类名
接口名
另一个泛型字母

==注意:==
1.可以组合使用
2.多个泛型约束 用`where`链接即可

## 练习

### 第一题
用泛型实现一个单列模式基类