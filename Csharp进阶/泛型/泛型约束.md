## 什么是泛型约束

==**让泛型的类型有一定的限制**==
关键字:`where`
泛型约束一个有**6种**
1.值类型                         `where` 泛型字母:`struct`
2.引用类型                       `where` 泛型字母:`class`
3.存在无参公共构造函数             `where` 泛型字母:`new()`
4.某个类本身或者其派生类           `where` 泛型字母:类名
5.某个接口的派生类型               `where` 泛型字母:接口名
6.另一个泛型类型本身或者派生类型     `where` 泛型字母:另一个泛型字母

`where` 泛型字母:(**约束的类型**)

### 各泛型约束讲解

#### 值类型约束
```C#
class Test1<T> where T : struct
{
    public T value;
    public void TestFun<K>(K k) where K : struct
    {

    }
}
```

```C#
//值类型约束
Test1<int> t1 = new Test1<int>();
t1.TestFun<float>(1.1f);
```

#### 引用类型约束
```C#
class Test2<T> where T : class
{
    public T value;
    public void TestFun<K>(K k) where K : class
    {

    }
}
```

```C#
//引用类型约束
Test2<Random> t2 = new Test2<Random>();
t2.value = new Random();
t2.TestFun<object>(new object());
```

#### 公共无参构造约束
```C#
class Test3<T> where T : new()
{
    public T value;
    public void TestFun<K>(K k) where K : new()
    {

    }
}
class Test1
{

}
class Test2
{
    public Test2(int a)
    {

    }
}
```

```C#
//公共无参构造约束
Test3<Test1> t3 = new Test3<Test1>();
//Test3<Test2> tt3 = new Test3<Test1>();
```

#### 类约束
```C#
class Test4<T> where T : Test1
{
    public T value;
    public void TestFun<K>(K k) where K : Test1
    {

    }
}
class Test3:Test1
{

}
```

```C#
//类约束
Test4<Test3> t4 = new Test4<Test3>();
```

#### 接口约束
```C#
interface IFly
{

}
class Test4 : IFly
{

}
class Test5<T> where T : IFly
{
    public T value;
    public void TestFun<K>(K k) where K : IFly
    {

    }
}
```

```C#
Test5<IFly> t5 = new Test5<IFly>();
```

#### 另一个泛型约束
```C#
class Test6<T,U> where T : U
{
    public T value;
}
```

```C#
//另一个泛型约束
Test6<Test4,IFly> t6 = new Test6<Test4,IFly>();
```

### 约束的组合使用
逗号分隔
```C#
class Test7<T> where T : class, new()
{

}
```

### 多个泛型有约束
```C#
class Test8<T,K> where T:class,new() where K : struct
{

}
```

### 总结

泛型约束:让类型有一定限制
`class`
`struct`
`new()`
类名
接口名
另一个泛型字母

==注意:==
1.可以组合使用
2.多个泛型约束 用`where`链接即可

## 练习

### 第一题
用泛型实现一个单列模式基类 [单例模式](../../Csharp核心/面向对象_封装/静态成员%20静态类和静态构造函数.md)
```C#
class SingleBase<T> where T : new()
{
    private static T instance = new T();
    public static T Instance
    {
        get
        {
            return instance;
        }
    }
    public int v;
}

class GameMgr : SingleBase<GameMgr>
{
    public int v;
}
```

```C#
Test.Instance.v = 1;
SingleBase<GameMgr>.Instance.v = 2;
GameMgr.Instance.v = 11;
```


### 第二题
利用泛型知识点 仿照`ArrayList`实现一个不确定数组类型的类
实现增删查改方法
```C#
class ArrayList<T>
{
    private T[] array;
    //当前存入的数量
    private int count;

    public ArrayList()
    {
        count = 0;
        //默认一开始容量就是16
        array = new T[16];
    }

    //增
    public void Add(T value)
    {
        //判断是否要扩容
        if(count >= Capacity)
        {
            //搬家 每次 家扩容两倍
            T[] temp = new T[Capacity * 2];
            for(int i = 0; i < Capacity; i++)
            {
                temp[i] = array[i];
            }
            //重定向
            array = temp;
        }
        //不需要扩容 直接加
        array[count] = value;
        count++;
    }

    //删
    public void Remove(T value)
    {
        //这个地方 不是小于数组的容量
        //是小于 具体存了几个值
        int index = -1;
        for(int i = 0; i < Count; i++)
        {
            //不能用==去判断 因为所有的类型都重载了运算符
            if (array[i].Equals(value))
            {
                index = i;
                break;
            }
        }
        //只要index不等于-1 就证明找到了 就去移除
        if(index != -1)
        {
            RemoveAt(index);
        }
    }
    //根据位置删除
    public void RemoveAt(int index)
    {
        //判断索引是否合法
        if(index < 0||index>= Count)
        {
            Console.WriteLine("索引不合法");
            return;
        }
        //后面往前放
        for (; index < Count - 1; index++)
        {
            array[index] = array[index + 1];
        }
        //把一个数移除了 后面的往前放 最后一个数也要依次
        array[Count - 1] = default(T);
        --count;

    }

    //查/改
    public T this[int index]
    {
        get
        {
            //判断索引是否合法
            if (index < 0 || index >= Count)
            {
                Console.WriteLine("索引不合法");
                return default(T);
            }
            return array[index];
        }
        set
        {
            //判断索引是否合法
            if (index < 0 || index >= Count)
            {
                Console.WriteLine("索引不合法");
                return;
            }
            array[index] = value;
        }
    }

    /// <summary>
    /// 获取当前容量
    /// </summary>
    public int Capacity
    {
        get
        {
            return array.Length;
        }

    }
    /// <summary>
    /// 获取当前具体存了多少个值
    /// </summary>
    public int Count
    {
        get
        {
            return count;
        }
    }
}
```

```C#
ArrayList<int> array = new ArrayList<int>();
Console.WriteLine(array.Count);
Console.WriteLine(array.Capacity);

Console.WriteLine("添加");
array.Add(1);
array.Add(2);
array.Add(3);
array.Add(4);
Console.WriteLine(array.Count);
Console.WriteLine(array.Capacity);


Console.WriteLine("查询");
Console.WriteLine(array[1]);
Console.WriteLine(array[-1]);
Console.WriteLine(array[3]);


Console.WriteLine("删除");
array.Remove(2);
Console.WriteLine(array.Count);

Console.WriteLine("遍历打印");
for (int i = 0; i < array.Count; i++)
{
    Console.WriteLine(array[i]);
}

Console.WriteLine("修改");
Console.WriteLine(array[0]);
array[0] = 999;
Console.WriteLine(array[0]);

ArrayList<string> array2 = new ArrayList<string>();
```