## 泛型是什么
泛型实现了==**类型参数化**== 达到代码重用目的
通过类型参数化来实现==同一份代码上操作多种类型==

泛型相当于**类型占位符**
定义类或方法时**使用替代符代表[变量类型](../../Csharp入门/数据变量类型.md)**
当真正**使用**类或者方法**时在具体指定类型**

### 泛型分类
**泛型类**和**泛型接口**
基本语法:
`class` 类名<泛型占位字母>
`interface` 接口名<泛型占位字母>

泛型函数
==基本语法:函数名<泛型占位字母>(参数列表)==

==注意:==泛型占位字母可以有多个 用逗号分开

### 泛型类和接口

泛型类
```C#
class TestClass<T>
{
    public T value;
}

class TestClass2<T1,T2,T3,K,M,Key,Value>
{
    public T1 value1;
    public T2 value2;
    public T3 value3;
    public K value4;
    public Key value5;
    public M value6;
    public Value value7;
}
```

泛型接口
```C#
interface TeatInterface<T>
{
    T Value { get; set; }
}
```
继承
```C#
class Test : TeatInterface<int>
{
    public int Value { get; set; }
}
```

### 泛型方法
1.普通类中的泛型方法
 ```C#
   class Test2
   {
       public void TestFun<T>(T value)
       {
           Console.WriteLine(value);
       }

       public void TestFun<T>()
       {
           //用泛型类型 在里面做一些逻辑处理
           T t = default(T);
       }

       public T TestFun<T>(string v)
       {
           return default(T);
       }

       public void TestFun<T,K,M>(T t,K k,M m)
       {

       }
   }
 ```

2.泛型类中的泛型方法
```C#
    class Test2<T>
    {
        public T value;
        public void TestFun<K>(K k)
        {
            Console.WriteLine(k);
        }

        //这个方法不叫泛型方法 因为 T是泛型类声明的时候 就指定 在使用这个函数的时候
        //我们就不能再去动态的变化了
        public void TestFun(T t)
        {

        }
    }
```

### 泛型的作用
1.不同类型对象的相同逻辑处理就可以选择泛型
2.使用泛型可以一定程度避免装箱拆箱
举例:优化`ArrayList`
```C#
class ArrayList<T>
{
    public T[] array;
    public void Add(T value)
    {

    }
    public void Remove(T value)
    {

    }
}
```

