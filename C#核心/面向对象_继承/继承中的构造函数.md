### 继承中的构造函数

#### 总结:

继承中的构造函数
==特点:==
**执行顺序** 先执行父类的构造函数 在执行子类的(从老祖宗开始 **依次一代一代向下执行**)

**父类**中的**无参构造很重要**
**如果被顶掉** **子类就无法默认调用**无参构造了
==解决方法:==
1.**始终**保持**声明一个无参构造**
2.通过`base`关键词 **调用指定的父类构造**
==注意:==
区分`this`和`base`的区别

#### 基本概念

 ==特点:==
 先声明一个子类对象时
 先执行父类的构造函数
 在执行子类的构造函数

 ==注意:==
 1.**父类**的**无参构造**函数 **很重要**
 2.**子类**可以通过`base`关键字 **代表父类 调用父类构造**

#### 继承中构造函数的执行顺序

父类的父类的构造函数 ---> 父类的构造 -->...--->子类的构造函数

```c#
class GameObject
{
    public GameObject()
    {
        Console.WriteLine("1.GameObject的构造函数");
    }
}
class Player:GameObject
{
    public Player()
    { 
        Console.WriteLine("2.Player的构造函数");
    }
}
class MainPlayer : Player
{
    public MainPlayer()
    {
        Console.WriteLine("3.MainPlayer的构造函数");
    }
}
```

```c#
//父类的父类的构造函数 ---> 父类的构造 -->...--->子类的构造函数
MainPlayer mainPlayer = new MainPlayer();
```

#### 父类的无参构造函数(重要)

**子类实例化**时 **默认**自动**调用**的 是**父类的无参构造** 所以**如果父类无参构造被顶掉 会报错**

```c#
class Father
{
    //public Father()
    //{

	 //}
    public Father(int i)
    {
        Console.WriteLine("Father的构造");
    }
}

class Son : Father
{
    #region 知识点四 通过base调用指定父类的构造(没有默认调用无参构造)
    public Son(int i) : base(i)
    {
        Console.WriteLine("Son的第一个参数的构造");
    }
    #endregion
    public Son(int i,string str) : this(i)
    {
        Console.WriteLine("Son的第二个参数的构造");
    }
}
```

```c#
Son s = new Son(1,"1");
```



---
