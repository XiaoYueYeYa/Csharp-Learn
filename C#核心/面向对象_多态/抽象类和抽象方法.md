### 抽象类和抽象方法
[[面向对象]]

#### 总结

==抽象类:== 被`abstract`修饰的类 **不能被实例化** **可以包含抽象方法**
==抽象方法:== 没有方法体的**纯虚方法** **继承后必须去实现**的方法
==注意:==
**如何选择普通类还是抽象类**(==作用:==)
不希望被实例化的对象 相对比较抽象的类可以使用抽象类
父类中的行为不太需要被实现的 只希望子类去定义具体的规则的 可以选择 抽象类然后使用其中的抽象方法来定义规则
==作用:==
整体框架设计时 会使用

#### <span id="抽象类">抽象类</span>

==概念:==
被抽象关键字`abstract`**修饰的类**
==特点:==
1.**不能被实例化**(但是可以**遵循里氏替换原则** **用父类容器装子类**)
2.**可以包含抽象方法**
3.**继承抽象类必须重写其抽象方法**

```c#
abstract class Thing
{
    //抽象类中 封装的所有知识点都可以在其中书写
    public string name;
    //可以在抽象类中写抽象方法
}
class Water:Thing 
{ 
    
}
```

```c#
//抽象不能被实例化
//Thing t = new Thing();
//但是 可以遵循里氏替换原则 用父类容器装子类
Thing t = new Water();
```

#### 抽象方法

纯虚方法
用`abstract`关键字修饰的方法
==特点:==
1.**只能**用**在抽象类中声明**
2.**没有方法体{}**
3.**不能**是**私有**的
4.**继承**后**必须实现** 用`override`重写

```c#
abstract class Fruits
{
    public string name;
    //抽象方法 是一定不能有函数体{}的
    public abstract void Bad();
    //虚方法
    public virtual void Test()
    {
        //可以选择是否写逻辑
    }
}
class Apple : Fruits
{
    //继承后必须实现用override重写
    public override void Bad()
    {
        
    }
}
class SuperApple : Apple
{
    //虚方法和抽象方法 都可以被子类无限的 去重写
    public override void Bad()
    {
        base.Bad();
    }
    public override void Test()
    {
        base.Test();
    }
}
```



---
