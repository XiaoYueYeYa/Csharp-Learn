### <span id="接口">接口</span>

#### 总结
[[../面向对象_继承/继承的基本规则]]
[继承类](#继承类):是**对象间的继承** 包括特征行为等等
==继承接口:==是**行为间的继承** 继承接口的行为规范 按照规范去实现内容
由于**接口**也是**遵循里氏替换原则** 所以**可以用接口容器装对象**

==注意:==
1.接口值**包含** **成员方法** **属性** **索引器** **事件** 并且**都不实现 都没有访问修饰符**
2.可以**继承多个接口** 但是**只能继承一个类**
3.**接口可以继承接口** **相当于**在进行**行为合并** **待子类继承时**再去**实现具体的行为**
4**.接口可以被显示实现** 主要用于实现不同接口中的同名函数的不同表现
5.**实现的接口** 可以加`virtual`关键字 **之后子类 在重写**

#### 接口的概念

**接口是行为的抽象规范**
它也是一个**自定义类型**
==关键词:==`interface`

接口声明的==规范:==
1.**不包含成员变量**
2.**只包含方法 属性 索引器 事件**
3.**成员不能被实现**
4.成员可以不用写访问修饰符 **不能是私有的**
5.**接口不能继承类** 但是**可以继承另一个接口**

接口的使用==规范==
1.**类可以继承多个接口**
2.**类继承接口后 必须实现接口中的所有成员**

==特点:==
1.它和类的声明类似
2.接口是用来继承的
3.接口**不能被实例化** 但是**可以作为容器存储对象**

#### 接口的声明

**接口关键字**:`interface`
==语法:==

```
interface 接口名
{

}
```

一句话记忆:接口是一个**抽象行为的"基类"**
**接口命名规范 帕斯卡前面加"I"**

```c#
interface IFly
{
    //方法
    void Fly()
    {

    }
    //属性
    string Name
    {
        get;
        set;
    }
    //索引
    int this[int index]
    {
        get;
        set;
    }
    //事件
    event Action doSomthing;
}
```

#### 接口的使用 

```c#
    //接口用来继承
    class Animal
    {

    }
    //1.类可以继承1个类,n个接口
    //2.继承了接口后 必须实现其中的内容 并且必须是public的
    class Person : Animal, IFly
    {
        //3.实现的接口函数 可以加virtual再在子类重写
        //方法
        public virtual void Fly()
        {

        }
        //属性
        public string Name
        {
            get;
            set;
        }
        //索引
        public int this[int index]
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }
        //事件
        public event Action doSomthing;
    }
    //4.接口也遵循里氏替换原则
```

```c#
 //4.接口也遵循里氏替换原则
 IFly f = new Person();
```

#### 接口可以继承接口

```c#
//接口继承接口时 不需要实现
//待类继承接口后 类自己去实现所有内容
interface IWalk
{
    void Walk();
}
interface IMove : IFly, IWalk
{

}
//类继承接口后 类自己去实现所有内容
class Test : IMove
{
    public int this[int index] { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }

    public string Name { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }

    public event Action doSomthing;

    public void Walk()
    {
        throw new NotImplementedException();
    }
}
```

```c#
 //4.接口也遵循里氏替换原则
IMove im = new Test();
IFly ifly = new Test();
IWalk iw = new Test();
```

#### 显示实现接口

当**一个类继承两个接口**
**但是接口**中**存在着同名方法时**
==注意:==显示实现接口时 不能写访问修饰符

```c#
interface IATk
{
    void Atk();
}
interface ISuperAtk
{
    void Atk();
}
class Player : IATk, ISuperAtk
{
    //显示实现接口 就是用 接口名:行为名 去实现
    void IATk.Atk()
    {
        
    }
    void ISuperAtk.Atk()
    {
        
    }
    public void Atk()
    {

    }
}
```

```c#
Player p = new Player();
(p as IATk).Atk();
(p as ISuperAtk).Atk();
```



---
