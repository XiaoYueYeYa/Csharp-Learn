构造函数和析构函数(和垃圾回收)

#### 总结:

==构造函数==
实例化对象时 调用的函数
主要是用来初始化成员变量的
基本语法
不写返回值
函数名和类名相同
访问修饰符根据需求而定
一般为`public`
==注意:==
可以重构构造函数
可以用`this`语法重用代码
可以在函数中用this区分同名参数和变量
**有参构造会顶掉默认**的**无参构造**

==析构==当垃圾回收时 调用的 主要是用来回收资源或者特殊处理内存的
基本语法
**不写**返回值
**不写**修饰符
**不能**有参数
函数名和类名**一致**
类名前面加`~`



#### 基本概念

在**实例化对象时** 会调用的用于初始化的函数
如果不写 **默认会存**在**一个无参数构造函数**

==构造函数==的写法
1.没有返回值
2.函数名和类名**必须相同**
3.没有特殊需求时 一般都是`public`

```c#
    class Person
    {
        public string name;
        public int age;
        //类中是允许自己声明无参构造函数的
        //结构体是不允许的
        public Person() 
        {
            name = "Jie";
            age = 18;
        }        
       
        public Person(string name) 
        {
            this.name = name;
        }        
        public Person(int age) 
        {
            this.age = age;
        }
        //4.构造函数可以被重载
        public Person(string name,int age):this(age + 10)
        {
        //5.this代表当前调用函数里创建的对象自己
            this.name = name;
            this.age = age;
        }
        //当引用类型的堆内存被回收时 会调用该函数
        //析构函数 是当垃圾 真正被回收的时候 才会调用的函数
        ~Person()
        {

        }
    }



        Person p = new Person("Yue",18);
        Console.WriteLine(p.name);

        p = null;
```

==注意:==
如果不自己(写)实现无参构造函数而(写了)实现了有参构造函数
会**失去**默认的**无参构造**

#### 构造函数特殊写法

可以通过`this` 重用构造函数代码
访问修饰符 构造函数名(参数列表):this(参数1,参数2...)
**先执行this的函数** 然后在去执行 this前面的函数

```c#
public Person(string name, int age) : this(age + 10)
{

}
```

#### 析构函数

==基本概念==
当引用类型的堆内存被**回收时 会调用该函数**
对于需要手动管理内存的语言(如:C++) 需要在析构函数中做一些内存回收处理
但是C#中存在自动垃圾回收机制GC
所以我们激活不会怎么使用析构函数.除非你想在某一个对象**被垃圾回收时 做一些特殊处理**
==注意:==
在unity开发中析构函数几乎不会使用 了解即可

基本语法

```c#
~类名()
{

}
```

#### 垃圾回收机制

==垃圾回收== 英文简写 **GC(Garbage Collector)**
垃圾回收的过程是在遍历堆(`heap`)上动态分配的所有对象
通过识别它们是否被引用来确定哪些对象仍要被使用
所谓的**垃圾** 就是**没有被任何变量** 对象**引用的内容**
垃圾就需要被回收释放

**垃圾回收有很多算法**,比如
引用计数(Reference Counting)
标记清除(mark Sweep)
标记整理(Mark Compact)
复制集合(copy Collection)

==注意:==
**GC**只负责堆(Heap)内存的垃圾
引用类型都是存在堆(`Heap`)中的 所以它的分配和释放都通过垃圾回收机制来管理

栈(`Stack`)上的内存是由系统自动管理的
值类型在栈(`Stack`)中分配内存的 他们有自己的生命周期 不用对他们进行管理 会自动分配和释放

**C#中内存回收机制的大概原理**

**分代算法:**

<img src="笔记图片/分代算法.png" style="zoom:60%;" align="left" />


0代内存   1代内存   2代内存
代的概念:
代是垃圾回收机制使用的一种算法(**分代算法**)
新分配的对象都是被配置的第0代内存中
每次分配都可能会进行垃圾回收以释放内存(0代内存满时)

在一次内存回收过程开始时 垃圾回收器会认为堆中全是垃圾 会进行以下两步
1.标记对象 从根(静态字段 方法参数)开始检查 引用对象 标记后可达对象 未标记为不可达对象
 不可达对象就认为是垃圾
2.搬迁对象压缩堆 (挂起执行托管代码线程)释放释放未标记的对象 搬迁可达对象 修改引用地址

大对象总认为是第二代内存 目的是减少性能损耗 提高性能
不会对大对象进行搬迁压缩 85000字节(83kb)以上的对象为为大对象

==手动触发垃圾回收的方法==
一般情况下 不会频繁的调用
都是在**Loading过场景**时 才调用

```c#
GC.Collect();
```



---
