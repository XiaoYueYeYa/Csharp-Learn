# C#入门

## 变量类型

### 数据变量类型

#### 无符号变量

​                                                                      

> * <span id="byte">byte</span>: 1字节  8位  1~128
>
> * <span id="ushort">ushort</span>: 2字节  16位   0~65535
> * <span id="uint">**uint**</span>: 4字节  32位  0~4294967295     ==常用==
> * <span id=ulong>*ulong*</span>: 8字节  64位  0~18446744073709551615    <kbd>不常用</kbd>

****

#### 有符号变量

> * <span id="sbyte">sbyte</span>: 1字节  8位   -128~127
> * <span id="short">short</span>: 2字节  16位  -32768~32767
> * <span id="int">**int**</span>: 4字节  32位  -2147483648~2147483647    ==常用==
> * <span id="long">*long*</span>: 8字节  64位  -9223372036854775808~9223372036854775807   <kbd>不常用</kbd>



#### 浮点类型

[单精度与双精度](https://blog.csdn.net/x18094/article/details/84147423)

> * <span id="float">float</span>: 4字节  32位单精度实数  -2^128 ~ 2^128
> * <span id="double">double</span>: 8字节  64位双精度实数  -2^1024  ~ 2^1024
> * <span id="decimal">decimal</span>: 16字节  128位      <kbd>不常用</kbd>


#### 特殊类型

> * <span id="string">string</span>: 字符串类型（文字）
> * <span id="char">char</span>: 储存单个字符  char a='a'; 使用单引号 范围：u+0000~u+FFFF
> * <span id="bool">bool</span>: 布尔值  true真  false假    



------



### 变量

* 拓展知识：折叠代码

```c#
	#region 标题        
    //主要作用 是让我们编程时 逻辑更加清晰
    //他是有 #region #endregion配对出现的
    //他的具体作用 是可以将中间包裹的代码折叠起来 避免代码太凌乱
   #endregion
```



#### 变量的命名规则

//1.不能重名
//2.不能以数字开头
//3.不能使用程序关键词命名
//4.不能有特殊符号 除下划线_外

//建议的命名规则：变量名一定要有含义 最好使用英语 不行拼音
//~~最好~~不要用汉字去命名

#### 1.常用命名规则

//驼峰命名法——首字母小写，之后单词首字母大写（变量）
//如

```C#
string myName = "筱";
string woDeMingZi = "筱";
```

//帕斯卡命名法——所以单词首字母大写（函数，类）

```C#
string MyName = "xiao";
```

//潜在知识点-C#中对大小写敏感 区分大小写



#### 2.申明变量

> ##### **变量声明固定写法:**
>
> 变量类型 变量名(可自定义) = 初始值;   （一定要记住 各种不同变量类型 所能存储的类型

```c#
//sbyte   --128~127
sbyte sb = 127;
//int   --21亿~21亿多
int i = 2;
//short   --32768~32767之间的数
short s = 3;
//long   --9百万兆~9百万兆之间的数
long l = 4;
//2.无符号的整形变量 是能存储 一定范围 0和正数的变量类型
//byte   0~255
byte b = 1;
//uint   0~42亿多的一个范围
uint u = 2;
//ushort 0~65535之间的一个数
ushort us = 3;
//ulong  0~18百万兆之间的数
ulong ul = 4;
//3.浮点数（小数）
//float 存储7到8位的有效数字 根据编译器不同 有效数字也可能不一样 四舍五入
//有效数字 是从左到右从非0数开始算有效数字
//之所以要在后面加个f 是因为C#中 声明的小数 默认是double类型 加f是告诉系统他是float类型
float f = 0.1111144445f;
//double 存储15~17位有效数字 抛弃的数字会四舍五入
double d = 0.01111111111111111112321;
//decimal 存储27~28位有效数字 不建议使用
decimal de = 0.0123456789765432344m;
//4.特殊类型
//bool 布尔类型true/false
bool bo = true;
bool bl = false;
//char 用来存储单个字符的变量类型
char c = '筱';
//string 字符串类型无上限
string str = "无上限字符";
```



> **多个同类型变量声明**
> 固定写法 如下用逗号隔开
>
> ```C#
> int a = 1, b = 2, c = 3, d = 4;
> string str = "第一个", str2 = "第二个";
> ```
>



> 变量声明时 可以**不设置初始值** 但是不建议这样写 这样<u>不安全</u>
>
> ```C#
>  int i;
>  i = 1;
> ```



#### 3.变量的存储空间(内存中）

> //1byte = 8bit
> //1KB = 1024byte
> //MB = 1024KB
> //1GB = 1024MB
> //1TB = 1024GB 

通过**`sizeof`**方法 可以获取变量类型所占的内存空间（单位：字节）

```C#
        //有符号
        int sbyteSize = sizeof(sbyte);
        Console.WriteLine("sbyte所占的字节数位：" + sbyteSize);
        int intSize = sizeof(int);
        Console.WriteLine("int所占的字节数位：" + intSize);
        int shortSize = sizeof(short);
        Console.WriteLine("short所占的字节数位：" + shortSize);
        int longSize = sizeof(long);
        Console.WriteLine("long所占的字节数位：" + longSize);
        //无符号
        int byteSize = sizeof(byte);
        Console.WriteLine("byte所占的字节数位：" + byteSize);
        int uintSize = sizeof(uint);
        Console.WriteLine("uint所占的字节数位：" + uintSize);
        int ushortSize = sizeof(ushort);
        Console.WriteLine("ushort所占的字节数位：" + ushortSize);
        int ulongSize = sizeof(ulong);
        Console.WriteLine("ulong所占的字节数位：" + ulongSize);
        //浮点数
        int floatSize = sizeof(float);
        Console.WriteLine("float所占的字节数位：" + floatSize);
        int doubleSize = sizeof(double);
        Console.WriteLine("double所占的字节数位：" + doubleSize);
        int decimalSize = sizeof(decimal);
        Console.WriteLine("decima所占的字节数位：" + decimalSize);
        //特殊类型
        int boolSize = sizeof(bool);
        Console.WriteLine("float所占的字节数位：" + boolSize);
        int charSize = sizeof(char);
        Console.WriteLine("double所占的字节数位：" + charSize);
```

​    **`sizeof`**是不能够得到**[string](#string)类型**所占的内存大小的
​    因为字符串长度是**可变**的 **不定**的



#### 4.变量的本质（理论）

//变量的本质是2进制-->计算机中所有数据的本质都是二进制 是一堆的0和1
//数据传递只能通过电信号，只有开和关两种状态，所以就用0和1来表示这两种状态
//计算机中的存储单位最小位bit（位）， 他只能表示0和1两个数字
//1bit 就是一个数 要么是1要么是0
//为了方便数据表示
//出现一个叫byte（字节）的单位，他是由8个bit组成的存储单位
//所以我们一般说一个字节位8位
//1byte = 0000 0000
//二进制和十进制对比
//二进制和十进制互相转换



------



### 常量

关键词：`const`

固定写法：`const` 变量类型 变量名 = 初始值；

如：

```C#
const int i = 1;
```

特点：

* ==必须初始化（必须要赋初始值）==
* ==不能被修改==

作用：**<u>声明一些常用但不变的值</u>**



------



## 转义字符

什么是转义字符？
他是字符串是一部分 用来表示特殊含义的字符
比如：在字符串中表现 单引号 引号 空行等等

#### 1.转义字符的使用

固定写法：  `\字符`
不同的 \和字符的组合 表示不同的含义

==**常用的转义字符**==

```C#
 //单引号  \'
 string str = "\'单引号\'";
 //双引号  \"
 str = "\"双引号\"";
 //换行   \n
 str = "换行\n换行";
 //斜杠   \\
 str = "斜杠\\斜杠";
```

<kbd> **不常用的转义字符**</kbd>

```C#
 //制表符(空一个tab键) \t
 str = "tab\ttab";
 //光标退格 （覆盖前一个字符）
 str = "退格\b退格";
 //空字符
 str = "空\0空";
 //警报音  \a
 str = "系统\a警报音";
```

#### 2.取消转义字符

双引号前面加`@`取消转义字符

```C#
string str2 = @"hhhh\hhhh";
```



------



## 类型转换

### 隐式转换

​        ==什么是转换类型==
​        类型转换 就是不同变量类型之间的相互转换

​        隐式转换的基本规则-->不同类型之间自动转换
​        大范围装小范围

#### 相同大类型之间的转换

有符号 `long`->`int`->`short`->`sbyte`

```C#
long l = 1;
nt i = 1;
short s = 1;
sbyte sb = 1;
//隐式转换 int隐式转换成了long
l = i;
//不能用小范围（小存储范围）的类型去装大范围（大存储范围）的类型
 i = l;（报错）
```

无符号 `ulong`->`uint`->`ushort`->`byte`(与有符号一样)



浮点数  `double` ->`float`    `decimal`

```C#
decimal de = 1.1m;
double d = 1.1;
float f = 1.1f;
d = f
f = d(报错)
```

 [decimal](#decimal)这个类型 ==没有办法==用隐式转换的形式 去存储 double和float
 ’float可以转换double

#### 不同大类型之间的转换

#### 无符号和有符号之间

无符号 **不能**装负数的

```c#
byte b2 = 1;//0~255
ushort us2 = 1;
uint ui2 = 1;
ulong ul2 = 1;
```

有符号

```c#
sbyte sb2 = 1;
short s2 = 1;
int i2 = 1;
long l2 = 1;
```

无符号装有符号
有符号的变量 是**不能**够 隐式转换成 无符号的

```c#
byte b2 = 1;
sbyte sb2 = 1;
int i2 = 1;
uint ui2 = 1;

i2 = sb2;
ul2 = sb2;
```

> 有符号装无符号:
> 有符号变量 **是可以** 装无符号变量的 前提是 ==不能超出范围== 存在隐式转换
> `i2 = ui2;`因为 有符号的数 ==可能会超过== 这个无符号变量的范围
> `i2 = b2;`因为 有符号的数 不管是多少 都在无符号变量的**范围内**

#### 浮点数和整数（有 无符号）之间

浮点数装整数

```c#
float f2 = 1.1f;
double d2 = 1.1;
decimal de2 = 1.2m;
```

==浮点数== 可以装载**任何**类型的 **整数**

```c#
f2 = l2;
f2 = ul2;
f2 = s2;
f2 = sb2;

f2 = 10000000000000000000;
Console.WriteLine(f2);
```

`decimal` **不能**隐式储存 `float`和`double`
<u>但是他可以隐式的存储整形</u>

```c#
de2 = l2;
de2 = ul2;
```

`double`->`float`->所以整形
`decimal`->所有整形

整数装浮点数 整数**不能**存储浮点数

```c#
i2 = f2;（报错）
```

#### 特殊类型和其他类型之间

特殊类型 `bool` `string` ~~`char`~~
他们之间 ==不存在==隐式转换

`bool` 没有办法和其他类型 相互隐式转换

```c#
bool bo = true;
int i = 2;
float f = 1.1f;
bo = i;
i2 = bo;（报错）
```

`char` 没办法隐式存储 其他类型的变量

```c#
char c = 'x';
c = i;
c = f;（报错）
```

`char`类型 **可以**隐式转换成 **整形和浮点型**
`char`隐式转换成 数值类型是
**相对**的数字 的一个 **ASCII码**
计算机里面存储4二进制
<u>字符 中文 英语 标点符号 在计算机中都是一个数字</u>
一个字符 对应一个数字 ASCII就是一种对应关系

```c#
i = c;
Console.WriteLine(i);//相对的[数字/字符/标点]的ASCII码
f = c;
Console.WriteLine(f);
```

`string` 类型 **无法**和其他类型进行隐式转换

 

> 总结 ==隐式转换== 规则：
>
> * 高精度（大范围）装低精度（小范围）
> * `double` ——> `float` ——> `整数` ——> `char`
> * `decimal` ——> `整数` ——> `char`
> * `string` 和 `bool` **不参与**隐式转换规则



***



### 显示转换

==什么是显示转换==

显示转换——>手动处理 强制转换

#### 括号强转

作用：一般情况下将**高精度**的类型==强制转换==为**低精度**
语法：`变量类型` 变量名 =（`变量类型`）变量;
==注意==：**精度问题 范围问题**

相同大类型的整形
有符号的

```c#
sbyte sb = 1;
short s = 1;
int i = 1;
long l = 1;
```

括号强转 可能会出现范围问题 造成的==错误==

```c#
s = (short)i;
Console.WriteLine(s);
i = (int)l;
sb = (sbyte)s;
sb = (sbyte)i;
sb = (sbyte)l;
```

**无符号**整形 规则与**有符号**一样

```c#
byte b = 1;
uint ui = 1;
b = (byte)ui;
```

---

浮点之间

```c#
float f = 1.1f;
double d = 1.12223124523422f;
```

位数不一样 超出会**隐藏**掉 造成**精度丢失**

```c#
f = (float)d;
Console.WriteLine(f);
```

无符号和有符号

```c#
uint ui = 1;
int i = -1;
```

强转时 一定要==注意范围== 不然得到的结果 可能会有**异常**

```c#
ui = (uint)i;
Console.WriteLine(ui);
i = (int)ui;
```

浮点和整形
浮点强制转换整数 会**直接舍弃小数** 并且**不会**四舍五入

```c#
i = (int)1.24f;
Console.WriteLine(i);
```

`char`和`数值`类型

```c#
i = 'A';
char c = (char)i;
Console.WriteLine(c);
```

`bool`和`string`类型  ==不能转换==

```c#
bool bo = true;
int i = (bool)bo;（报错)
-----------------------------------------
string str = "123";
i = (string)str;(报错)
```

#### <span id="Parse">Parse法</span>

==作用==：把**[字符串](#string)**类型转换为**对应的类型**
==语法==：`变量类型.Parse("字符串");`
**注意**：字符串必须是**能够转换对应类型** 否则==报错==

[有符号](#int)

```c#
int i = int.Parse("123");
Console.WriteLine(i);
```

我们填写字符串 **必须**是要**能够**转换成对应类型的字符 如果==不符合==规则 ==会报错==

```c#
i = int.Parse("123.45");
Console.WriteLine(i);（报错）
```

值的范围**必须**是**能够**被变量存储的值 ==否则报错==

```c#
short s3 = short.Parse("400000");
Console.WriteLine(s3);
sbyte sb3 = sbyte.Parse("1");
Console.WriteLine(sb3);
Console.WriteLine(sbyte.Parse("1"));
Console.WriteLine(long.Parse("1"));
```

[无符号](#bytr)

```c#
Console.WriteLine(byte.Parse("1"));
Console.WriteLine(ushort.Parse("1"));
Console.WriteLine(ulong.Parse("1"));
Console.WriteLine(uint.Parse("1"));
```

[浮点数](#float)

```c#
float f3 = float.Parse("1.22222");
double d3 = double.Parse("1,888888888");
```

[特殊类型](#bool)

```c#
bool b5 = bool.Parse("true");
char c2 = char.Parse("X");
```

#### Convert法

==作用==：更准确的将 **各个类型**之间==相互转换==
语法：`Convert.To目标类型（变量或常量）`
**注意：**填写的变量或常量**必须正确** 否则报错

如果是把**字符串转对应类型** 那字符串一定要**合法合规**

```c#
int a = Convert.ToInt32("12");
Console.WriteLine(a);
```

精度比强转好 会**四舍五入**

```c#
a = Convert.ToInt32(1.51212f);
Console.WriteLine(a);
```

把**bool类型**也可以转换成 **数值类型** (true 1  /  false 0)

```c#
a = Convert.ToInt32(true);//1
Console.WriteLine(a);
a = Convert.ToInt32(false);//0
Console.WriteLine(a);
```

把**字符串类**型也可以转换成 **数值**

```c#
a = Convert.ToInt32('A');
Console.WriteLine(a);
```

==每一个类型都对应的 Convert中的方法==

```c#
sbyte sb =Convert.ToSByte("1");
short s =Convert.ToInt16("1");
int i =Convert.ToInt32("1");
long l =Convert.ToInt64("1");

byte b = Convert.ToByte("1");
ushort us = Convert.ToUInt16("1");
uint ui = Convert.ToUInt32("1");
ulong ul = Convert.ToUInt64("1");

float f =Convert.ToSingle("13.2");
double d =Convert.ToDouble("13.2");
decimal de =Convert.ToDecimal("13.2");

bool bo = Convert.ToBoolean("true");
char c =Convert.ToChar("X");
string str =Convert.ToString("ghua");
```

#### 其他类型转string

==作用==：拼接打印
语法：`变量.toString` 

```c#
string str = 1.ToString();
str = true.ToString();
str = 'A'.ToString();
str = 1.2f.ToString();

int a = 1;
str =a.ToString();
bool bo = true;
str =bo.ToString();
```

当我们进行**字符串拼接时** 就会**自动调用** `toString` 转成`string`

```c#
Console.WriteLine("1233" + 1 + true);
str = "1233" + 1 + true + 1.23;
```



---



## 异常捕获

==作用==：通过异常捕获 可以**避免**当代码报错时 造成程序**卡死**的情况

如：将玩家输入的内容 存储到string类型的变量（容器）中
string str = Console.ReadLine();
使用[Parse法](#Parse)转字符串为数值类型时 必须要 合法合规 否则报错
int i= int.Parse(str);

==语法==：

```c#
try
{
    //希望进行异常捕获的代码块
    //放在try中
    //如果try中的代码报错 不会造成程序卡死 如果出错将跳转到catch代码块
}
catch(Exception ex)
//catch (Exception ex) 具体报错跟踪 可以通过ex得到 具体的错误信息 可以省略(Exception ex)
{
    //如果报错将执行该代码块 来捕获异常
}
//可选部分
finally
{
    //最后执行的代码 不管有没有出错 都会执行其中的代码
}
```



---



## 算数运算符

#### 赋值符号

`=`
==关键==知识点;
 先看**右侧再看左侧** 把**右侧**的**赋值**给**左侧**的变量

```c#
string name = "xiao";
int age = 17;
```

#### 算数运算符

> 加 `+`
> 用自己计算 **先算右侧**结果 在赋值给左侧变量
>
> ```c#
> int i = 1;
> i = i + 2;//3
> Console.WriteLine(i);
> ```
>
> 连续运算 **先算右侧**结果 在赋值给左侧
>
> ```c#
> i = 1 + 2 + 3 + 4 + i + i;//16
> Console.WriteLine(i);
> i = 1 + 2 + 3;//6
> Console.WriteLine(i);
> ```
>
> 初始化时运算 **先算右侧**结果 在赋值給左侧
>
> ```c#
> int i2 = 1 + 2 + 3;
> ```
>
> 减 `-` 一致
> 乘 `*` 一致
> 除 `/` 一致

**默认**的整数是**int**
==求小数== 必须有一个数要==加f==

```c#
float f = 1 / 2f;
Console.WriteLine(f);
```

取余数 `%`

```c#
int y = 4;
y = y % 2;
Console.WriteLine(y);
```

#### 算数运算符的优先级

==优先级== 是指 在混合运算时的**运算顺序**

```c#
int a = 1 + 2 * 3 / 2 + 1;
Console.WriteLine(a);

a = 1 + 4 % 2 * 3 / 2 + 1;
Console.WriteLine(a);
```

==乘除取余== 优先级高于 ==加减== **先算乘除取余 后算加减**
**括号可以改变优先级** 先计算括号内的内容

```c#
a = (1 + 4 ) * 3 / 2 + 1;
Console.WriteLine(a);
```

多组括号 **先算最里层的括号** 依次往外计算

#### 复合运算符

==固定写法== `运算符=`
`+=`  `-=`  `*=`  `/=`  `%=`
复合运算符 是用于 自己进行运算（用**自己加上某个值 在赋值给自己** ）
复合运算符 只能进行一种运算 **不能混合运算**

```c#
int i3 = 1;
i3 = i3 + 2;
Console.WriteLine(i3);

i3 = 1;
i3 += 2;//展开就是i3 = i3 + 2;
Console.WriteLine(i3);
```

#### 算术运算符的自增减

```c#
int a2 = 1;
a2 = a2 + 1;

a2 = 1;
a2 += 1;
```

自增运算符 ==让自己+1==

```c#
a2=1;
a2++;//先用后加
Console.WriteLine(a2);
++a2;//先加后用
Console.WriteLine(a2);

a2 = 1;
Console.WriteLine(a2++);//1
//a2=2
Console.WriteLine(++a2);//3
```

自减号运算符 ==让自己-1== （规则**与自增一致**）

只有 `+`  `-`  没有  `*`  `/`  `%`



---



## 字符串拼接

#### 方法一

之前的运算符 只是用来数值类型变量进行数学运算的
而`string`不存在算数运算符**不能计算** 但是**可以通过+加号来进行字符串拼接**

```c#
string str = "123";
```

用`+`加号进行字符串拼接

```c#
str = str + "456";
Console.WriteLine(str);//123456
str = str + 1;
Console.WriteLine(str);//1234561
```

复合运算 `+=`

```c#
str = "123";
str += "1" + 4 + true;
Console.WriteLine(str);//12314True

str += 1 + 2 + 3 + 4;//12314True10
Console.WriteLine(str);
```

**左边为字符串**时则后面默认为字符串类型**不会相加**
反之**右边为字符串则会相加**

```c#
str += "" + 1 + 2 + 3 + 4;
Console.WriteLine(str);//12314True101234

str +=1 + 2 + "" + 3 + 4;
Console.WriteLine(str);//12314True101234334
```

**括号会更改优先级** 先计算括号

```c#
str = "";
str += 1 + 2 + "1" + (3 + 4);
Console.WriteLine(str);//317
```

==注意==：用 `+` 拼接 是用符号==唯一==的方法 不能用 `-` `*` `/` `%`

#### 方法二

==固定语法==:`string.Format("待拼接的内容",内容1,内容2,....)；`
拼接内容中的固定规则 想要被拼接的内容**用站位符替代{数字}** 数字：**0~n 依次往后**

```c#
string str2 = string.Format("我是{0}, 我今年{1}","xiao",18);
Console.WriteLine(str2);//我是xiao，今年18

string str3 = string.Format("{0},{1},{2}",1,true,"xiao");
Console.WriteLine(str3);//1，true，xiao
```

#### 方法三

与字符串拼接方法二 `string.Format` **类似**
后面的内容比占位符 **多不会报错 反则报错**

```c#
Console.WriteLine("A{0},B{1},C{2}",1,2,3);
```



---



## 条件运算符

#### 条件运算符

用于比较两个变量或常量
是否**大于** `>`
是否**小于** `<`
是否**等于** `==`
是否**不等于** `!=`
是否**大于等于** `>=`
是否**小于等于** `<=`

条件运算符 ==一定存在==左右两边的内容
左边的内容 条件运算符 右边的内容

```c#
int a = 5;
int b = 10;
```

==条件运算符== **不能这样直接使用**

```c#
a>b
```

比较的结果 返回的是 一个==bool类型的值==
true和false 如果比较的**条件满足** 那就返回**true** **不满足** 就返回**false**
**先计算右边 在赋给左边**

```c#
bool bo = a > b;
Console.WriteLine(bo);

bo = a < b;
Console.WriteLine(bo);

bo = a >= b;
Console.WriteLine(bo);

bo = a <= b;
Console.WriteLine(bo);

bo = a == b;
Console.WriteLine(bo);
```

#### 各种应用的写法

`变量`和`变量`的比较

```c#
a=5;
b=10;
bo = a < b;//ture
```

`变量`和`数值`的比较

```c#
bo = a < 10;//ture
bo = b > 5;//ture
```

`数值`和`数值`的比较

```c#
bo = 5 > 3;
bo = 5 == 4;
bo = 5 != 5;
```

计算结果之间的比较
==条件运算符 优先级低于 算数运算符==
**先计算后比较**

```c#
bo = a + 3 > a - 2 + 3;
```

#### 不能进行范围比较

判断是否在某两个值之间

```c#
a = 5;
```

==在C#不能这么写==

```c#
1 < a < 5;
```


要判断 一个变量是否在两个数之间 要结合 **逻辑运算符**的知识点

#### 不同类型之间的比较

不同类型之间 ==可以随意==进行比较 条件运算符

```c#
int i = 5;
float f = 1.2f;
double d = 12.4;
short s = 2;
byte by = 20;
uint ui = 222;
```

**只要是数值** 就能进行条件运算符比较

```c#
bo = i > f;
bo = f < d;
bo = i < by;
bo = f > ui;
bo = ui > d;
```

特殊类型 ~~`char`~~ `string` `bool` 只能==同类型比较== == 和 != 比较

```c#
char c = 'A';
string str = "123";
bool bo = true;

bo = str == "134";//false
bo = str == "123";//ture
bo = str != "123";//false

bo = c == 'B';//false
```

char**不仅**可以和自己类型进行 == !=比较 **还可以**和数值类型进行比较 
还可以和 **字符类型进行大小写比较**

```c#
bo = c > 123;

bo = bo==true;//true
```



---



## 逻辑运算符

对==bool类型== 进行==逻辑运算符==

### 运算符

#### 逻辑与

符号：`&&`
规则 对两个`bool`值进行逻辑运算 **有假则假 同真为真**

```c#
bool bo = true && false;
Console.WriteLine(bo);
bo = true && true;
Console.WriteLine(bo);
```

`bool`相关的类型 `bool`变量 条件运算符
==逻辑运算符优先级 低于条件运算符<算数运算符==

```c#
true&&true
bo = 3 > 1 && 1 < 2;
Console.WriteLine(bo);

int i = 3;
1<i<5;
true && true
bo = i > 1 && i < 5;
Console.WriteLine(bo);
```

多个逻辑与 **组合运用**

```c#
int i2 = 5;
true && false && ture &&true
bo = i2 > i && i2 < 5 && i > 1 && i < 5;
Console.WriteLine(bo);
```

#### 逻辑或

符号：`||`
规则 对两个`bool`值进行逻辑运算
**有真则真**（有一个真就是true） **同假为假**（两个假才位false）

```c#
bo = true || false;
Console.WriteLine(bo);
bo = true || true;
Console.WriteLine(bo);
```

**同假为假**

```c#
bo = false || false;
Console.WriteLine(bo);

bo = 3 > 10 || 3 < 5;
Console.WriteLine(bo);

int a = 5;
int b = 11;
bo = a > 1 || b < 20 || a > 5;
Console.WriteLine(bo);
```

  ? && ?
  ?  ||  ?
 ?可以是写死的**bool变量** 或者 **bool值**
 还可以是 **条件运算符相关**

#### 逻辑非

符号： `!`
规则 对一个**bool值**进行取反 **真变假 假变真**

```c#
bo = !true;
Console.WriteLine(bo);
bo = !false;
Console.WriteLine(bo);

bo = !!true;//两个感叹号不变 true
Console.WriteLine(bo);
```

==逻辑非 优先级 较高 (要加括号)==

```c#
bo = !(3 > 2);
Console.WriteLine(bo);
```

### 混合使用优先级

规则 `!`(逻辑非)优先级最高  `&&`(逻辑与)优先级高于`||`(逻辑或)
**逻辑运算符优先级** 低于 **算数运算符** **条件运算符** ==逻辑非除外==

```c#
 bool gameOver = false;
 int hp = 100;
 bool isDead = false;
 bool isMustOver = true;

false || false && true || true;
false || false || true;
 result = gameOver || hp < 0 && !isDead || isMustOver;
 Console.WriteLine(result+"活着");
```

### 逻辑运算符的短路规则

#### 逻辑运算符<span id="短路">短路 </span>规则

```c#
int i3 = 1;
```

**有真则真**
只要 逻辑与或者逻辑或 **左边满足了条件**

```c#
i3 > 0 //true
```

**只要 满足条件** **右边的内容** 对于我们来说 **就已经不重要了**

```c#
result = i3 > 0 || ++i3 >= 1;
Console.WriteLine(result);

false && i3 ++ > 1;//抛弃后面不去计算
result = i3 < 0 && i3++ > 1;
Console.WriteLine(i3);
Console.WriteLine(result);
```



---



## 位运算符

位运算符 主要用数值类型进行计算的
将数值**转换为2进制** 再进行**运算**

#### 位与 &

==规则==: 连接两个数值进行位计算  将数值**转为2进制**
对位运算(向下对位) **有0则0**

```c#
int a = 1;// 001
int b = 5;//101
//  001  |
//& 101  |
//  001  ˇ
int c = a & b;
Console.WriteLine(c);//001

a = 3;//   011
b = 19;//10011
c= a & b;
//  00011
//& 10011
//  00011
Console.WriteLine(c);//00011

int d = a & b & c;
Console.WriteLine(d);
```

#### 位或 |

==规则==： 连接；连接两个数值进行计算 将数值**转换为2进制**
对位运算(向下对位) **有1则1**

```c#
a = 1;
b = 3;
c = a | b;
//  001
//| 011
//  011
Console.WriteLine(c);//011

a = 5; //  101
b = 10;// 1010
c = 20;//10100
Console.WriteLine(a | b | c);//11111
```

#### 异或 ^

==规则==： 连接；连接两个数值进行计算 将数值**转换为2进制**
对位运算 **相同为0 不同为1**

```c#
a = 1;//001
b = 5;//101
 //    100
c = a ^ b;
Console.WriteLine(c);//101

a = 10;//1010
b = 11;//1011
c = 4;//  100

Console.WriteLine(a ^ b ^ c);//1111
```

#### 位取反 ~

==规则==： 连接；连接两个数值进行计算 将数值**转换为2进制**
对位运算 **0变1 1变0**

**int 4个字节 8位**

```c#
a = 5;//0101
//0000 0000 0000 0000 0000 0000 0000 0101
//1111 1111 1111 1111 1111 1111 1111 1010
```

//反码补码知识

```c#
c = ~a;
Console.WriteLine(c);//1111 1111 1111 1111 1111 1111 1111 1010
```



#### 左移<<和右移>>

==规则== 连接；连接两个数值进行计算 将数值转**换为2进制**
**左移几位 右侧加几个0**

```c#
a = 5;//101
```

向左移动5位

```c#
c = a << 5;
//1位 1010
//2位 10100
//3位 101000
//4位 1010000
//5位 10100000
Console.WriteLine(c);//10100000
```

**右移几位 左侧去掉几个数**

```c#
a = 5;//101
c = a >> 2;
 //1位 10
 //2位 1
Console.WriteLine(c);//1
```



---



## 三元运算符/三目运算符

#### 基本语法

==固定语法==： 空位    ？ 空位
关键信息：`bool类型` `?` bool类型为真返回内容 `:` bool类型为假返回内容;
三目运算符 会有返回值，这个返回值类型**必须一致**，并且**必须使用**！

#### 具体使用

```C#
string str = true ? "条件位真" : "条件位假";
Console.WriteLine(str);
str = false ? "条件位真" : "条件位假";
Console.WriteLine(str);

int a = 5;
str = a > 1 ? "a大于1" : "a不满足条件";
Console.WriteLine(str);

int i =a>1 ? 123 : 456;
//第一个空位 始终是结果为bool类型的表达式 bool变量 条件表达式 逻辑运算符表达式
//第2 3个空位 什么表达式都行 只要保证他们的结果类型是一致的

bool b = a > 1 ? a > 6 : !false;
```



---



## 条件分支语句

### 条件分支语句_if

==作用==：让顺序执行的代码 产生分支
            if语句是第一个 可以让我们的程序 **产生逻辑变化**的 语句
	     ==作用==：满足条件时 多执行一些代码

#### 1.if语句

==语法==：

> `if`( `bool类型` )  //bool类型相关：**bool变量** **条件运算符表达式** **逻辑运算符表达式**
> {
>   满足条件执行的代码;
> }

**注意**：
1.if语句的语法部分 **不需要分号**
2.if语法**可以嵌套**使用

```c#
if (true)
{
    Console.WriteLine("if执行的代码1");
    Console.WriteLine("if执行的代码2");

}
Console.WriteLine("if后面的代码");
---------------------------------------------------------------------------------
int a = 1;
if (a > 0 && a < 5)
{
    Console.WriteLine("满足条件");
}
Console.WriteLine("33333333333.两个条件");
---------------------------------------------------------------------------------
string name = "xiao";
string passWord = "666";
if (name == "xiao" && passWord == "666")
{
    Console.WriteLine("正确");
}
```

==嵌套使用==

```c#
if (name == "xiao")
{
    Console.WriteLine("用户名正确");
    if (passWord == "666")
    {
        Console.WriteLine("密码正确");
    }
}
```



#### 2.if…else语句

==作用==：产生**两条分支** **满足条件**做什么 **不满足**做什么

==语法==：

> `if`(`bool类型`){
> 	 满足执行b的代码;
> }
> `else`{
>        不满足执行的代码;
> }

**注意**：
if...else 语句 语法部分 **不需要写分号**
if...else 语句 **可以嵌套**

```c#
if (true)
{
    Console.WriteLine("满足条件");
}
else
{
    Console.WriteLine("不满足条件");
}
```

其他的使用和if是一样的

#### 3.if…else if…else 语句

==作用==：产生**N条分支** **最先满足**其中的条件 就做什么

==语法==：

> `if`(`bool类型`)
> {
>   	满足执行的代码;
> }
> `else if`(`bool类型`)
> {
>   	满足执行的代码;
> }
>    <!--中间可以有N个else if语句代码块-->
> `else`
> {
>   	不满足执行的代码;
> }

**注意**：

1.和前面两个是**一样**的 **不需要分号**
2.是**可以嵌套**的
3.else是**可以省略**的
4.条件判断 从**上往下执行** **满足第一个**后 之后的都**不会执行**

```c#
int a3 = -1;
if (a3 >= 10)
{
    Console.WriteLine("a大于等于10");
}else if(a3 >= 5 && a3 <= 10)
{
    Console.WriteLine("a在5和10之间");
}else if(a3 >= 0 && a3 <= 5)
{
    Console.WriteLine("a在0和5之间");
}
else
{
    Console.WriteLine("a小于0");
}
```



---



### 条件分支语句_switch

==作用==：让顺序执行的代码 **产生分支**

#### 1.基本语法

> `switch` (变量)
> {
>     <!--//变量 == 常量-->
>     `case` 常量:
>         	满足后执行的代码
>         `break`;
>     `case` 常量:
>         	满足后执行的代码
>         `break`;
>         <!--case可以有无数个-->
>     `default`:
>         	如果上面的`case`的条件都不满足 就会执行 `default`（`default`可以省略不写
>         `break`;
> }

**注意**：常量！！**只能写一个值** 不能去写一个范围 **不能写条件运算符和逻辑运算符**
`switch` **只判断变量是否等于某个值** 可以**嵌套使用**

```c#
int a = 3;
switch (a)
{
    case 3:
        Console.WriteLine("a=3");
        break;
    case 2:
        Console.WriteLine("a=2");
        break;
    case 1:
        Console.WriteLine("a=1");
        break;

default:
    Console.WriteLine("都不满足执行");
    break;
}
```

#### 2.可自定义常量

```c#
char c = 'A';
 //1.必须初始化 2.不能修改
 const char c2 = 'A';
 switch (c)
 {
     case c2:
         break;
     default:
         break;
 }
```

#### 3.贯穿

==作用==：满足某些条件时 **做的事情是一样的** 就可以使用**贯穿**

```c#
int a = 1;
switch (aa)
{
    //不写case后面配对的break 就叫贯穿
    //满足 1 2 3其中一个条件 就会执行 之后的代码
    case 1:
    case 2:
    case 3:
        Console.WriteLine("满足条件");
        break;
default:
    break;
}
```



---



## 循环语句

### 循环语句_while

==作用==： 让顺序执行的代码 可以**不停的循环执行某一代码**块的内容

#### 语法相关

==bool类型的变量 条件运算符 逻辑运算符==

> `while` (`bool类型`)
> {
> 	当**满足条件**时 就会**执行while语句块中的内容**
> 	当代码逻辑执行完 会**回到whike循环开头**
> 	**再次**进行条件判断
> }

==死循环==  <kbd>不常用</kbd>
死循环只有在 学习控制台程序是 会频繁使用
进入Unity过后 基本不会使用  <kbd>不常用</kbd>
1.可能会因为内存问题 造成**程序崩溃 闪退**
2.造成**程序卡死**

```c#
//死循环
while (true)
{
    //Console.WriteLine("***********");
}
```

计算一个为0的整形变量 让他只能累加一 不停加到10

```c#
int i = 0;
//bool类型的值 还可以用逻辑运算符 && || ！条件运算符 算数运算符结合运算
while (i + 1 < 10)//只要是bool类型都行
{
    ++i;
}
Console.WriteLine(i);
```

#### 嵌套使用

不仅可以==嵌套== `if` `switch` 还可以while


```C#
int a = 0;
int b = 0;
while (a<10)
{
    ++a;
    //要循环执行完b才能跳出a循环
    while (b < 0)
    {
        ++b;
    }
}
----------------------------------------------
a = 0;
b = 0;
while (a < 10)
{
    ++a;
    if (b < 10)
    {
        ++b;
    }
}
```

#### 流程控制关键词

==作用==：控制循环逻辑的关键词
`break`:**跳出循环**

```c#
while(true)
{
    Console.WriteLine("break前的代码");
    break;
    Console.WriteLine("break后的代码");//不执行 直接跳出循环
}
Console.WriteLine("循环外的代码");

int i1 = 0;
while (true)
{
    ++i1;
    Console.WriteLine(i1);
    if (i1 == 10)
    {
        break;//跳出循环
    }
}
```

`continue`:**回到循环 继续执行**

```c#
while (false)
{
    Console.WriteLine("continue前的代码");
    continue;
    Console.WriteLine("continue后的代码");
}
Console.WriteLine("continue外的代码");
```

打印1到20之间的 奇数

```c#
int index = 0;
while (index < 20)
{
    ++index;
    //什么样的数是奇数
    //不能被2整除的数 - %
    if (index % 2 == 0)
    {
        continue;
    }
    Console.WriteLine(index);
}
```

**注意**：`break`和`continue`主要是和循环配合使用的 和**`if`语句没关**
==break在switch中的作用 和 while循环中的作用有异曲同工之妙==



---



### 循环语句_do...while

`do…while`循环 **至少执行一次**循环语句块的逻辑 **在判断**是否继续

#### 基本语法

`do`
{
    //do while循环语句块
} `while` (`bool类型`);

**注意**: `do…whilr` 语句存在一个重要的**分号**;

#### 实际使用

```c#
do
{
    Console.WriteLine("do while 循环语句块");
} while (false);

int a = 0;
do
{
    Console.WriteLine(a);
    ++a;
} while (a < 2);
```

#### 嵌套使用

`if` `switch` `while` `do...while`都能嵌套使用

```c#
do 
{
   if (true){

	}
	while (false){

	}
	switch (a){

	}
		Console.WriteLine("1111111");
continue;
}while (false);
```



---



### 循环语句_for

#### 基本语法

==语法==：
`for`(`初始表达式`; `条件表达式`; `增量表达式`)
{
	循环代码逻辑;
}
`初始表达式`：一般声明一个**临时变量** 用来计数用
`条件表达式`: 表明进入循环的条件 一个**bool类型**的结果
`增量表达式`：用第一个空中变量 进行 **自增减运算**

**第一次**进行循环时 才会调用 **第一个**空中逻辑
**每次**进入循环之前 都会**判断第二个中空的条件** **满足才会进入循环逻辑**

```c#
for(int i = 0;i < 10; i++)
{
    Console.WriteLine(i);
    //执行完循环语句中的逻辑后
    //最后执行第三个中空的代码
}
```

递减

```c#
for (int i = 10; i >= 0; i--)
{
    Console.WriteLine(i);
}
```

> 每个空位 可以按照规则进行书写：
> ==第一个空位== 就是**声明变量** 所以可以连续声明
> ==第二个空位== 就是进入条件 只要是**bool结果的表达式** 都可以
> ==第三个空位== 就是**执行一次循环逻辑后要做的事情** 做啥都行

```c#
for (int i = 0,j = 0; i < 10 && j<0 ; ++i, j = j + 1)
{
    Console.WriteLine(i);
}
```

#### 支持嵌套

```c#
for(int i = 0;i < 10; i++)
{
    for(int o = 0;o < 10; o++)
    {
        Console.WriteLine(i+"_"+o);
    }
    while (false)
    {	
        
	 }
	  if(true)
	 {
          
	  }
}
```

#### 3.特殊写法

`for`循环**3个空位** 可以都**空着** 可以根据需求去填写

```c#
for循环可以写死循环
for (;;)
{
    Console.WriteLine("for的死循环");
}
int k = 0;
for (; k < 10;)
{
    ++k;
}
```

#### 对比while循环

`for`循环 一般用来可以==准确得到== 一个范围中的所以数

```c#
for (int i = 0; i < 10; i++)
{

}

int j = 0;
while (j < 1)
{

}
```



---



# C#基础



## 枚举

#### 基本概念

###### 枚举是什么

==枚举==是一个比较特别的存在
它是一个**被命名**的整形常量的**集合**
<u>一般用它来表示 状态 类型 等等</u>

###### 声明枚举 和 声明枚举变量

**注意**：==声明枚举== 和 ==声明枚举变量== 是**两个概念**
==声明枚举==：相当于是 创造一个自定义的枚举类型
==声明枚举变量==：使用声明的自定义枚举类型 创造一个枚举变量

###### 声明枚举语法

**枚举名** 以**E**或者**E_**开头 作为我们的**命名规范**  

```c#
enum E_自定义枚举名
{
    自定义枚举向名字,   //枚举中包裹的 整形变量 **默认值是0** 下面会**依次累加1**
    自定义枚举向名字1,  //1
    自定义枚举向名字2,  //2
    自定义枚举向名字3,  //3
}

enum E_自定义枚举名
{
    自定义枚举向名字 = 5,        //第一个枚举项的默认值 变成5了
    自定义枚举向名字1,          //6
    自定义枚举向名字2 = 100,      //无论前一个是什么 都会一直加1 
    自定义枚举向名字3,          //101
    自定义枚举向名字4,          //102
}
```



#### 在哪里声明枚举

1.`namespace`语句块中（常用）
2.`class`语句块中 `struct`语块中
**注意**：枚举**不能**在**函数语句块**中声明！！！非常重要

#### 枚举的使用

声明==枚举==

```C#
enum E_MonsterType
{
    Normal,//0
    Boss,//1
}

enum E_PlaterType
{
    Main,
    Other,
}
```

声明==枚举变量==
上面自定义枚举(名)类型 (新自定义)变量名 = 默认值(自定义的枚举类型.枚举项);
              (自定义枚举名 变量命 = 自定义枚举名.自定义枚举向名字;)

```C#
E_PlaterType platerType = E_PlaterType.Main;
if (platerType == E_PlaterType.Main)
{
    Console.WriteLine("主玩家逻辑");
}
else if (platerType == E_PlaterType.Other)
{
    Console.WriteLine("其他玩家逻辑");
}
//枚举和switch是天生一对
E_MonsterType monsterType = E_MonsterType.Boss;
switch (monsterType)
{
    case E_MonsterType.Normal:
        Console.WriteLine("普通怪物逻辑");
        break;
    case E_MonsterType.Boss:
        Console.WriteLine("Boss逻辑");
        break;
    default:
        break;
}
```

#### 枚举的类型转换

1.==枚举==和`int`互转

```c#
int i = (int)platerType;
Console.WriteLine(i);
```

`int` 转==枚举==

```c#
platerType = 0;

//(枚举名)int类型
```

2.==枚举==和`string`转换

```c#
string str = platerType.ToString();
Console.WriteLine(str);
```

把`string`转成==枚举==
`parse` 第一个参数：你要转为的是那个类型 枚举类型 第二个参数：用于转换的对应枚举的字符串
转换完毕后 是一个通用的类型 我们需要用**括号强转**成我们想要的枚举类型

```c#
platerType = (E_PlaterType)Enum.Parse(typeof(E_PlaterType), "Other");
Console.WriteLine(platerType);

int a = int.Parse(Console.ReadLine());
```

#### 枚举的作用

在游戏开发中 **对象**很多时候 会有**许多个状态**
比如玩家 有一个动作状态 我们需要一个变量或者标识 来**表示**当前玩家**处于**的是**那种状态**
综合考虑 可能会使用 `int` 来表示他的状态
1行走 2待机 3跑步 4跳跃....等等

==枚举==可以帮助我们 **清晰的分清楚状态的含义**



---



## 数组

### 一维数组

#### 基本概念

==数组==是**存储**一组**相同类型**数据的**集合** 
==数组==分为 ==一维== ==多维== ==交错数组==
一般情况 **一维数组** 就**简称**为**数组**

#### 数组的声明

`变量类型`[] 数组名;  //**只**是声明了数组 但并没有在内存“开房” 
==任何变量类型都可以==

```C#
int[] arr;
arr = new int[10];
```

`变量类型`[] 数组名 = new 变量类型[数组的长度]

```C#
int[] arr2 = new int[5];//这种方式 相当于开了5个房间 但房间的int值 默认为0
```

`变量类型`[] 数组名 = new 变量类型[数组的长度]{内容1,内容2,内容3,内容4....}

```C#
int[] arr3 = new int[5] { 1, 2, 3, 4, 5 };
```

`变量类型`[] 数组名 = new 变量类型[]{内容1,内容2,内容3,内容4....}

```C#
int[] arr4 = new int[] {1,2,3,4,5};//后面的内容决定了 数组的长度（房间数）
```

`变量类型`[] 数组名 = {内容1,内容2,内容3,内容4....};

```C#
int[] arr5 = { 1, 2, 3, 4, 5 };//后面的内容决定了 数组的长度（房间数）

bool[] arr6 = new bool[] { true, false };
```

#### 数组的使用

```c#
int[] array = { 1, 2, 3, 4, 5 };
```

1.数组的长度
数值变量名.`Length`（长度）

```c#
Console.WriteLine(array.Length);
```

2.**获取**数组中的元素
数组中的下标和索引 他们是**从0开始**的
**不能越界** 数组的房间号 范围是 0 ~ `Length`-1

```c#
Console.WriteLine(array[0]);
Console.WriteLine(array[4]);
```

3.**修改**数组中的元素
数组名[房间号] = 新的值;

```c#
array[0] = 999;
Console.WriteLine(array[0]);
```

4.**遍历**数组 通过循环 快速获取数组中的每一个元素

```c#
for (int i = 0; i < array.Length; i++)
{
    Console.WriteLine(array[i]);
}
```

5.**增加**数组元素
数值初始后 是不能够 直接添加新的元素的!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

```c#
int[] array2 = new int[6];//新的大房子 
```

搬家

```c#
for (int i = 0;i < array.Length; i++)
{
    array2[i] = array[i];
}
array = array2;
for (int i = 0; i < array.Length; i++)
{
    Console.WriteLine(array[i]);
}
array[5] = 9999;
Console.WriteLine(array[5]);
```

6.**删除**数组元素
数值初始后 是不能够 直接删除元素的!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
搬家的原理

```c#
int[] array3  = new int[5];//新的小房子
```

搬家

```c#
for (int i = 0; i < array3.Length; i++)
{
    array3[i] = array[i];
}
array = array3;
Console.WriteLine(array.Length);
遍历
for (int i = 0; i < array.Length; i++)
{
    Console.WriteLine(array[i]);
}
```


删除对应数组

```c#
int[] numbers = { 1, 2, 3, 4, 5, 6 };
//移除的元素
int valueToRemove = 5;
//新建一个数组，长度为操作数组的长度-1
int[] newNumbers = new int[numbers.Length - 1];
int index = 0;
for (int i = 0; i < numbers.Length; i++)
{
   if (numbers[i] != valueToRemove)
   {
      newNumbers[index] = numbers[i];
      index++;
   }
}
numbers = newNumbers;
Console.WriteLine(String.Join(",", numbers ));
```

7.**查找**数组中的元素
比如要查找 3

```c#
int a = 3;
for (int i = 0; i < array.Length; i++)
{                    
    Console.WriteLine(array[i]);
    if (a == array[i])
    {
        Console.WriteLine("在{0}的位置上",i);
    }
}	
```



---



### 二维数组

#### <span id="ErWei">二维数组</span>的概念

==二维数组== 是使用**两个下标**（索引）来确定元素的数组
**两个下标**可以理解成 **行标** 和 **列标**
比如矩阵
1 2 3
4 5 6
可以用二维数组 `int`[**2**,**3**]表示
好比 **两行** **三列**的数据集合

#### 二维数组的声明

==各种写法==
变量类型[,] 二维数组变量名;

```c#
int[,] arr;//声明过后 会在后面初始化
```

变量类型[,] 二维数组变量名 = naw 变量类型[行,列];

```c#
int[,] arr2 = new int[3, 3];
```

变量类型[,] 二维数组变量名 = naw 变量类型[行,列]{ {0行内容1,0行内容2,0行内容3.....}, {1行内容1,1行内容2,1   行内容3.....}, .....};

```c#
int[,] arr3 = new int[3, 3] { { 1, 2, 3 },
                     { 1, 2, 3 },
                     { 1, 2, 3 }};
```

变量类型[,] 二维数组变量名 = naw 变量类型[,]{ {0行内容1,0行内容2,0行内容3.....}, {1行内容1,1行内容2,1   行内容3.....}, .....};

```c#
int[,] arr4 = new int[,] { { 1, 2, 3 },
                   { 1, 2, 3 }};
```

变量类型[,] 二维数组变量名 = { {0行内容1,0行内容2,0行内容3.....}, {1行内容1,1行内容2,1   行内容3.....}, .....};

```C#
int[,] arr5 = { { 1, 2, 3 },
           { 1, 2, 3 },
           { 1, 2, 3 }};
```



#### 二维数组的使用

==声明二维数组==

```c#
int[,] array = new int[,] { { 1, 2, 3 },
                            	{ 4, 5, 6 }};
```

1.二维数组的长度
我们要**获取** **行**和**列**分别是多长
得到多少==行==

```c#
Console.WriteLine(array.GetLength(0));
```

得到多少==列==

```c#
Console.WriteLine(array.GetLength(1));
```

2.**获取**二维数组中的**元素**
注意：**第一个**元素的**索引是0** 最后一个元素索引 肯定是 长度-1

```c#
Console.WriteLine(array[0, 1]);
Console.WriteLine(array[1, 2]);
```

3.==修改==二维数组中的元素

```c#
array[0, 0] = 99;
Console.WriteLine(array[0, 0]);
```

4.==遍历==二维数组
遍历行

```c#
for (int i = 0; i < array.GetLength(0); i++)
{
    //遍历列
    for (int j = 0; j < array.GetLength(1); j++)
    {
        //i 行 0 1
        //j 列 0 1 2
        Console.WriteLine(array[i, j]);
        //0,0 0,1 0,2
        //1,0 1,1 1,2
    }
}
```

5.==增加==数组的元素
数组 声明**初始化过后** 就**不能**再原有的基础上进行 **添加** 或者**删除**了

```c#
int[,] array2 = new int[3, 3];//新家
for (int i = 0; i < array.GetLength(0); i++)//遍历行
{
    for (int j = 0; j < array.GetLength(1); j++)//遍历列
    {
        array2[i, j] = array[i, j];//搬家
    }
}
array = array2;//重新赋值回去
//添加新数据 默认为0
array[2, 0] = 7;
array[2, 1] = 8;
array[2, 2] = 9;
//遍历 打印出来
for (int i = 0; i < array.GetLength(0); i++)
{
    for (int j = 0; j < array.GetLength(1); j++)
    {
        Console.WriteLine(array[i, j]);
    }
}
```

6.==删除==数组的元素

```c#
int[,] array3 = new int[2, 3];//新家
for (int i = 0; i < array3.GetLength(0); i++)
{
    for (int j = 0; j < array3.GetLength(1); j++)
    {
        array3[i, j] = array[i, j];//旧的赋值给新的
    }
}
array = array3;
遍历 打印出来
for (int i = 0; i < array.GetLength(0); i++)
{
    for (int j = 0; j < array.GetLength(1); j++)
    {
        Console.WriteLine(array[i, j]);
    }
}


```

7.==查找==数组中的元素
如果要在数组中查找一个元素是否等于某个值
通过**遍历**的形式去**查找**

```c#
int a = 3;
array[0, 2] = 1;

for (int i = 0; i < array.GetLength(0); i++)
{
    for (int j = 0; j < array.GetLength(1); j++)
    {

   if (a == array[i, j])
    {
         Console.WriteLine("数值：" + a + " 在{0}行 第{1}列 有", i, j);
    }
    else if (a != array[i, j])
    {
        Console.WriteLine("没有");
    }
}

}
```



---



### 交错数组（拓展

总结:
概念:交错数组 可以存储同一类型的m行不确定列的数据
要掌握的内容:声明 遍历 增加 删除 查看 修改
**所有的**变量类型都可以申明为 交错数组
一般交错数组很少使用 <kbd>了解即可</kbd>

#### 交错数组的概念

==交错数组== 是 数组的数组 每个维度的数量可以不同

**注意**：[二维数组](#ErWei)的每行的列数相同 ==交错数组==每行的**列数可能不同**

#### 交错数组的声明

<!--变量类型[][] 数组名;-->

```c#
int[][] arr1;
```

<!--变量类型[][] 数组名 = new 变量类型[行数][];-->

```c#
int[][] arr2 = new int[2][];
```

<!--变量类型[][] 数组名 = new 变量类型[行数][]{一维数组1,一维数组2,一维数组n....};-->

```c#
int[][] arr3 = new int[3][] { new int[] {1,2,3},
                     new int[] {1,2},
                     new int[] {1,}};
```

<!--变量类型[][] 数组名 = new 变量类型[][]{一维数组1,一维数组2,一维数组n....};-->

```c#
int[][] arr4 = new int[][] { new int[] {1,2,3},
                    new int[] {1,2},
                    new int[] {1,}};
```

<!--变量类型[][] 数组名 = {一维数组1,一维数组2,一维数组n....};-->

```c#
int[][] arr5 ={ new int[] {1,2,3},
           new int[] {1,2},
           new int[] {1,}};
```

#### 交错数组的使用

==声明交错数组==

```c#
int[][] array = {new int[] {1,2,3},
            new int[] {1,2}};
```

1.获取数组的==长度==

```c#
Console.WriteLine(array.GetLength(0)); //行
Console.WriteLine(array[0].Length);  //得到某一行的列数
```

2.获取交错数组中的==元素==
**注意**不要越界

```c#
Console.WriteLine(array[0][1]);//第0行的第1列
```

3.==修改==交错数组中的元素 

```c#
array[0][1] = 10086;
Console.WriteLine(array[0][1]);
```

4.==遍历==交错数组 

```c#
for(int i = 0; i < array.GetLength(0); i++)
{
    for(int j = 0; j < array[i].Length; j++)//遍历第i列
    {
        Console.Write(array[i][j]+" ");
    }
    Console.WriteLine();
}
```

5.==增加==交错数组的元素 

```c#
int[][] array_A = new int[3][] { new int[] { 1, 2, 3 },
     						  new int[] { 1, 2},
     						  new int[] { 1 },};

int[][] array_B = new int[4][]{ new int[] { 0, 0, 0},
                      new int[] { 0, 0, 0},
                      new int[] { 0, 0, 0},
                      new int[] { 0, 0, 0},};

for (int i = 0;i < array_A.GetLength(0); i++)
{
		for(int j = 0;j < array_A[i].Length; j++)
		{
				array_B[i][j] = array_A[i][j];
		}
}
```

6.==删除==交错数组的元素 

```c#
int[][] array0 = new int[3][] {new int[] {1,2,3},
                     new int[] {1,2},
                     new int[] {1}};

int[][] arr0 = new int[2][]{new int[] {0,0,0},
                   new int[] {0,0,}};//新家

for (int i = 0; i < arr0.GetLength(0); i++)
{
    for (int j = 0; j < arr0[i].Length; j++)
    {
        arr0[i][j] = array0[i][j];
    }
}
array0 = arr0;
```

7.==查找==交错数组中的元素 

```c#
int[][] array_C = new int[3][] {new int[] {1,2,3},
                      new int[] {5,6},
                      new int[] {7}};

for (int i = 0; i < array_C.GetLength(0); i++)
{
    for (int j = 0; j < array_C[i].Length; j++)
    {
        if (array_C[i][j] ==5)
        {
            Console.WriteLine(array_C[i][j]+"在第{0}行,第{1}列", i,j);
        }
    }
}
```



---



## 值类型和引用类型

#### 1.变量类型的复习

 ==无符号整形==

```c#
byte b = 1;
ushort us = 1;
uint ui = 1;
ulong ul = 1;
```

==有符号整形==

```c#
sbyte sb = 1;
short s = 1;
int i = 1;
long l = 1;
```

 ==浮点型==

```c#
float f = 1f;
double d = 1.1;
decimal de = 1.1m;
```

 ==特殊类型==

```c#
bool bo = true;
char c = 'a';
string str = "string";
```

==复杂数据类型==

```c#
enum 枚举
数组（一维 二维 交错）
```

把以上变量类型 分成 值类型和引用类型
==引用类型==:string,数组,类(没学
==值类型==:其他,结构体(没学

#### 2.值类型和引用类型的区别

使用上的区别

```c#
Console.WriteLine("值类型和引用类型的区别 值类型和引用类型的区别 值类型和引用类型的区别 值类型和引用类型的区别 值类型和引用类型的区别");
```

==值类型==

```c#
int a1 = 10;
```

==引用类型==

```c#
int[] arr1 = new int[] {1,2,3,4,5};
string str1 = "第一个";//特殊的引用类型（它变我不变
```

声明了一个b1让其等于之前的a1

```c#
cint b1 = a1;
```

声明了一个arr2让其等于之前的arr1

```c#
int[] arr2 = arr1;
```

声明了一个str2让其等于之前的str1

```c#
string str2 = str1;
Console.WriteLine("a={0} b={1}",a1,b1);c
Console.WriteLine("arr1[0]={0} arr2[0]={1}", arr1[0], arr2[0]);
Console.WriteLine("arr1={0} arr2={1}", str1, str2);
```

修改b1和arr2的值

```c#
Console.WriteLine();
b1 = 10086;
arr2[0] = 1145;
str2 = "第二个";
Console.WriteLine("修改b1和arr2后的值 修改b1和arr2后的值 修改b1和arr2后的值 修改b1和arr2后的值 修改b1和arr2后的值 修改b1和arr2后的值 ");
Console.WriteLine("a={0} b={1}", a1, b1);//修改后值不一样了
Console.WriteLine("arr1[0]={0} arr2[0]={1}", arr1[0], arr2[0]);//修改后两者的值都变成后面赋值的
Console.WriteLine("arr1={0} arr2={1}", str1, str2);
```

==值类型==：在**互相赋值**时 把内容拷贝给了对方 **它变我不变**
==引用类型==：<span id="值类型">在**相互赋值** 是让两者指向同一个值 **他变我也变**</span>

为什么有以上的区别

==值类型== 和 ==引用类型== 存储在的 内存区域 是不同的 **存储方式是不同**的
所以就造成了 他们使用上的区别



==值类型==存储在 **栈空间**--系统分配的空间，自动回收，内存小但速度快

<img src="笔记图片/栈与堆.jpg" align="left" style="margin-left: 0px; zoom: 67%;" />

==引用类型==存储在 **堆空间**--手动申请和释放，内存大但速度慢

<img src="笔记图片/引用类型赋值关系图.jpg" style="zoom: 67%; margin-left: 0px;" />

new 就等于开了一个新的空间 两者互不相干

```c#
arr2 = new int[] {99,2,3,5};
Console.WriteLine("arr1[0]={0} arr2[0]={1}", arr1[0], arr2[0]);
```





---



## 函数



### 基本<span id="函数">概念</span>

==函数== 也叫做 ==方法==
本质是一块**具有名称**的`代码块`
可以使用==函数==（方法）的**名称来执行**该代码块
函数（方法）是**封装代码**进行**重复使用**的一种机制
函数（方法）的**主要作用**：

> 1.封装代码
> 2.提升代码复用率（少些点代码）
> 3.抽象行为

==总结==
1.基本概念
2.函数写在哪里 --- `calss` 或 struct 中
3.基本语法  1  2  3  4  5
4.`return` 可以提前结束函数逻辑  (程序是线性执行的 **从上往下**

#### 函数写在哪里

>    1.`class`语句块中
>    2.`strucs`语句块中

#### 基本语法

```c#
1    2     3             4
static 返回类型 函数名(参数类型 参数名1,参数类型 参数名2,....)  //可以放无数个参数
{
 函数的代码逻辑;
 函数的代码逻辑;
 函数的代码逻辑;
 ...
   5
 return 返回值;  //如果有返回类型才返回

}
```

>1.关于`static` 它**不是必须**的 但在**没有**学习 `类` 和 `结构体`前 都是必须写的
>2.关于==返回类型== 新关键词 `void`(表示没有返回值)
>==返回类型== 可以写**任意**的**变量类型** 14种变量类型 + 复杂数据类型(数组 枚举 结构体 类)
>3.关于函数名 **自定义名称** 建议使用帕斯卡命名法(首字母大写)或驼峰命名法
>4.参数<u>不是必须</u>的 可以有**0~N个**参数类型可以是**任意类型** 14种变量类型 + 复杂数据类型(数组 枚举 结构体 类)
>参数名 **自定义** 建议使用帕斯卡命名或驼峰命名法
>5.当返回值类型**不为**`void`时 必须通过`return`返回对于类型的内容  (注意:即使是**void也可以使用return**)

#### 实际运用

```c#
//1/无参无返回值函数
1   2    3   4
static void Demo1()
{
	Console.WriteLine("Hello World");
  	  5 在没有返回值时 也就是返回值类型为void 可以省略
	return;
}

//2.有参无返回值函数
static void Demo2(string name)
{
	Console.WriteLine("你的名字是:{0}",name);
   	  5
	//return; 省略
}

//3.无参有返回值函数

1    2   3   4
static string Demo3()
{
	  5
	return "Xiao";
}

//4.有参有返回函数

1   2   3     4
static int Demo4(int a,int b)
{
	//int c = a+b;
	//return c;
	//  5  retrun后面可以写一个表达式 结果和返回值类型是一致的就行
	return a + b;
}

//5.有参有多返回值函数
//传入两个数 然后计算两个数的和 以及他们两的平均数 得出结果返回出来
//函数的返回 一定是一个类型 只能是一个内容
1   2   3     4
static int[] Demo5(int a,int b)
{
	int sum = a + b;
	int avg = sum / 2;
	//int[] arr = {sum,avg};
	//return arr;
	//一步到位:  5
	return new int[] {sum,avg};
//如果是用数组作为返回值出去 那么前提是 使用者 知道这个数组的规则
}
```

​    ==使用函数==

```c#
使用函数 直接 写函数名(参数) 即可

Demo1();
// 参数可以是 常量 变量 函数都可以
// 参数 一定是传一个 能够得到对应类型的表达式
string str = "XiaoYueYe";
//传入一个string变量
Demo2(str);
//传入一个string常量
Demo2("筱夜説");
//传入一个返回值是string的函数
Demo2(Demo3());
//有返回值的函数  要不是直接拿返回值来用
//就是拿变量 接收它的结果
string str2 = Demo3();
//也可以直接调用 但是 返回值 对我们来说就没有用了
Demo3();

Console.WriteLine(Demo4(2,5));

int[] arr = Demo5(5, 7);
Console.WriteLine(arr[0]+" " + arr[1]);

Demo6("SB");//关于return
```

#### 关于return

即使函数没有返回值 我们有可以使用`return`
`return` 可以直接不执行`return`之后的代码跳出函数

```c#
static void Demo6(string str)
{
    if (str == "SB")
      {
        return;
      }
      Console.WriteLine(str);
    }
    //或
static string Demo6_1(string str)
{
    if (str == "SB")
    {
		return "";
      }
		return(str);
    }
```

#### 练习题

##### 1.写一个函数,比较两个数字的大小,返回最大值

```c#
static int Demo1(int a, int b)
{
    //int max = 0;
    //if (a > b)
    //{
    //    max = a;
    //}
    //else
    //{
    //    max = b;
    //}
    //return max;
    if (a > b)
    {
        return a;//return 会直接跳出函数所以可以省略elst
    }
    return b;

    //三目运算符
    return a>b ? a:b;
}
```



##### 2.写一个函数 用于计算一个圆的面积和周长 并返回打印

```c#
static float[] Demo2(float r)
{
    //float PI = 3.1415926f;
    //float S = PI * (r * r);
    //float C = 2 * PI * r;
    //return new float[] { S, C };
    //老师的解法：
    float[] f = new float[2];
    f[0] = 3.14f * r * r;
    f[1] = 2 * 3.14f * r;
    return f;
    //一步到位
    return new float[] { 3.14f * r * r, 2 * 3.14f * r };

}
```



##### 3.写一个函数 求一个数组的总和 最大值 最小值 平均数

```c#
static void Demo3(int[] arr)
{
    if(arr.Length == 0)
    {
        Console.WriteLine("数组不能为空");
        return;
    }
    int max = arr[0];
    int min = arr[0];
    int sum = 0;
    int avg = 0;

    for (int i = 0; i < arr.Length; i++)
    {
        sum += arr[i];

        if (max < arr[i] )
        {
            max= arr[i];
        }
        if (min > arr[i])
        {
            min= arr[i];
        }
    }
    avg=sum/arr.Length;

    Console.WriteLine("最大值：{0} 最小值：{1} 总和：{2} 平均数：{3}",max,min,sum,avg);
}
```



##### 4.写一个函数,判断你传入的参数是不是质数 (质数：一个只能被1和自己整除的数)

```c#
 static bool Demo4(int num)
 {
     //判断质数的逻辑
     for(int i = 2; i < num; i++)
     {
         //得到从2到num-1之间的数
         if (num % i == 0)
         {
             //和循环配合使用 break continue
             return false;
         }
     }
     //默认认为他就是质数
     return true;
 }
```



##### 5.写一个函数,判断你输入的年份是否是闰年

```c#
static bool Demo5(int a)
{
    if (a % 400 == 0 || (a % 4 == 0 && a % 100 != 0))
    {
        return true;
    }

    //默认不是
    return false;
}
```



---



### ref和<span id="out">out</span>

#### 总结:

1.`ref`和`out`的作用:解决值类型和引用类型 在函数==内部== 改值 或者 **重新声明 能够影响外部传入**的变量 让其也被修改
2.使用上：就是在声明参数的时候 在**前面**加上 `ref`和`out`的关键词即可 使用上 同上
3.区别：
`ret`传入的变量==必须初始化== 但是在内部 **可改可不改**
`out`传入的变量**可以不用初始化** 但是在内部 ==必须修改值==

#### 学习ref和out的原因

他们可以解决 在函数**内部改变外部传入的内容** ==里面变了外面也要变==
`ref`和`out`的作用:解决**[值类型](#值类型)**和**[引用类型](#值类型)** 在函数内部进行 改值 或者 **重新声明 而能够影响外部传**入的变量 让其也被修改

```c#
//数组(值类型)
static void ChangeValue(int value)//传入a相当于在栈开了一个新的房间只在内部使用 跟外面的没有任何关系
{
    value = 3;
}

//数组(引用类型)
static void ChangeArrayValue(int[] arr)//将arr2堆的地址传到了这个
{
    arr[0] = 99;//把相同地址的堆里面的数改了 外面的数自然也就改了
}
//数组(引用类型) [但重新new一个]
static void ChangeArray(int[] arr)
{
    //new就是等于在堆里面重新开辟一个新的房间 地址不相同外面的自然也不会变
    arr = new int[] { 1, 2, 3 };
}
```



#### ref和out的使用

函数参数的==修饰符==
**当传入的值类型参数在内部修改时 或者引用类型参数在内部重新声明时**
外部的值**会发生变化**

```c#
//ref
static void ChangeValueRef (ref int value)//数值类型
{
    value = 99;
}

static void ChangeArrayRef(ref int[] arr)//引用类型
{
    arr = new int[] { 99,20,30 };
}

//out
static void ChangeValueOut(out int value)//数值类型
{
    //out 传入的变量必须在内部有进行赋值 ref不用
    value = 99;
}

static void ChangeArrayOut(out int[] arr)//引用类型
{
    arr = new int[] { 99, 20, 30 };
}
```

```c#
//(值类型)
int a = 1;
ChangeValue(a);//
Console.WriteLine(a);//输出1

//ret 
Console.WriteLine("ret后");
ChangeValueRef(ref a);
Console.WriteLine(a);//输出99

//out
Console.WriteLine("out后");
ChangeValueOut(out a);
Console.WriteLine(a);//输出99

//(引用类型)
int[] arr2 = {1,2,3};
ChangeArrayValue(arr2);
Console.WriteLine(arr2[0]);//输出99 

//(引用类型)[但重新new一个]
Console.WriteLine("new后");
arr2[0] = 1;
ChangeArray(arr2);
Console.WriteLine(arr2[0]);//输出1

//ref后
Console.WriteLine("new但ref后");
ChangeArrayRef(ref arr2);
Console.WriteLine(arr2[0]);//输出99

//ref后
Console.WriteLine("new但out后");
ChangeArrayOut(out arr2);
Console.WriteLine(arr2[0]);//输出99
```



#### ref和out的区别

`ref` 传入的变量**必须**先**初始化** `out`不用
`out` 传入的变量**必须在内部**有进行**赋值**  `ref`不用

`ret`传入的变量**必须初始化** 但是在内部 可改可不改
`out`传入的变量可以不用初始化 但是在**内部 必须修改值**



#### 练习题

##### 1.让用户输入用户名密码 返回应该bool类型的登录结果,而且还要返回单独的登录信息,如果用户名错误,除了返回登录结果自外,登录信息为“用户名错误”,如果密码错误,除了返回登录结果之外,登录信息为“密码错误”



```c#
static bool NamePwd(string name, string pwd , ref string info)
{
    string Myname = "xiao";
    string Mypwd = "123";
    
    if(name == Myname)
    {
        if (pwd == Mypwd)
        {
            info = "登录成功";
            return true;
        }
        else
        {
            info = "密码错误";
        }
    }
    else
    {
        info = "用户名错误";
    }
    return false;
}
```

```c#
Console.WriteLine("输入用户名");
string name = Console.ReadLine();
Console.WriteLine("输入密码");
string pwd = Console.ReadLine();
string inpo = "";
NamePwd(name, pwd,ref inpo);
while (!NamePwd(name, pwd, ref inpo))
{
    Console.WriteLine(inpo);
    Console.WriteLine("******************************");
    Console.WriteLine("输入用户名");
    name = Console.ReadLine();
    Console.WriteLine("输入密码");
    pwd = Console.ReadLine();
    
}
Console.WriteLine(inpo);
```



---



### 变长参数和参数默认值

#### 总结:

##### 一,变长参数关键词 params

==作用==:可以传入n个同类型的参数 **n可以是0**
注意:
1.`params`后面**必须是数组** 意味着只能是**同一类型**的**可变参数**
2.变长参数**只能有一个**
3.必须在所有参数**最后**写变长参数

##### 二,参数默认值(可选参数

==作用==:可以**给函数**的参数**默认值** 使用时可以不传参 **不传用默认值 传了就用传的**
注意:
1.可选参数**可以有多个**
2.可选参数**必须**写**在**正常参数的**后面**

#### 变长参数关键词

举例 函数要计算 n个整数的和

```c#
static int Sum（int a,int b,...){

}
```

使用变长参数关键词 `params`

```c#
static int Sum(params int[] arr)
{
    int sum = 0;
    for (int i = 0; i < arr.Length; i++)
    {
        sum += arr[i];
    }
    return sum;
}
```

```c#
Sum();
Sum(1,2,3,4);
```

`params int[] arr` 意味着**可以传入n个**int**参数** n可以等于0 传人的参数 会存在arr数组中
注意：
1.`params`关键词后面**必须为数组**
2.数组的类型**可以是任意的类型**

3.==函数参数==可以有 别的参数和`params`关键字修饰的参数
4.==函数参数==中**最多**只能出现**一个**`params`关键字 而且**一定**是**在最后一组参数** 它前面**可以写n个其他的参数**
4.列如:

```c#
static void cesi(string name,params string[] things)
{
        
}
```

#### 参数默认值

**有参数默认值**的参数 一般**称为可选参数**
==作用==:当**调用函数时可以不传人参数 不传就会使用默认值作为参数的值**
如:

```c#
static void Speak(string speak = "这个是默认参数")
{
    Console.WriteLine(speak);
}
```

```c#
//不传入则使用默认值
Speak();
Speak("123123132");
```

==注意:==
1.**支持多参数默认值** 每个参数**都可以有默认值**
2.如果要**混用** 可选参数 **必须写在 普通参数后面** (带默认值的必须卸载普通的后面 
如:

```c#
static void Speak2(string a,string b,string c = "默认值",string d = "可以有多个")
{

}
```

#### 练习

##### 第一题:使用param参数 求多个数字的和以及平均数

```c#
static void Age(params int[] args) 
{
    if (args.Length == 0)
    {
        Console.WriteLine("没有参数");
        return;
    }
    int sum = 0;
    for (int i = 0; i < args.Length; i++)
    {
        sum += args[i];
    }
    Console.WriteLine("总和:"+sum);
    Console.WriteLine("平均数:"+sum/args.Length);
}
```

##### 第二题:使用param参数 求多个数字的偶数和奇数和

```c#
static void Sum(params int[] args)
{
    if (args.Length == 0)
    {
        Console.WriteLine("没有参数");
        return;
    }
    int ONum = 0;
    int even = 0;
    for (int i = 0; i < args.Length; i++)
    {
        
        if (args[i]%2 != 0)
        {
            ONum += args[i];
        }
        else
        {
            even += args[i];
        }
    }
    Console.WriteLine("奇数和:" + ONum);
    Console.WriteLine("偶数和:" + even);
}
```



##### 输入

```c#
int[] arr = new int[5];
for (int i = 0;i < arr.Length;i++)
{
    Console.WriteLine("输入第{0}个数", i+1);
    int a = int.Parse(Console.ReadLine());
    arr[i]= a;
    Console.WriteLine();
}

Age(arr);
Sum(arr);
```



---



### 函数重载

#### 总结:

==概念==:**同一个**语句块中 **函数名相同** <u>参数**数量 类型 顺序 不同**的函数</u> 就称为我们的**重载函数**
注意:与返回值无关
==作用==:一般用来处理不同参数的同一类型的逻辑处理



#### 基本概念

==重载概念==
在**同一个语句块**(class或者struct)中
函数(方法)**名相同**
参数的**数量不同**
或者
参数的**数量相同**,但参数的**类型或顺序不同**

==作用==:
1.命名一组功能相似的函数 **减少函数名的数量 避免命名空间的污染**
2.**提升**程序的**可读性**

#### 实例

==注意:==
1.重载和**返回值的类型无关**,只和参数类型,个数,顺序有关
2.调用时 程序会自己**根据传入的参数**类型**自动判断使用哪一个重载**

```c#
static int Sum(int a,int b) 
{
 return a + b;
}
//参数数量不同
static int Sum(int a, int b , int c)
{
    return a + b + c;
}
//数量相同 类型不同
static float Sum(float a, float b)
{
    return a + b;
}
//数量相同 类型不同
static float Sum(int a, float f)
{
    return a + f;
}
//数量相同 顺序不同
static float Sum(float f, int a)
{
    return f + a;
}
```
#### ref和out

[跳转相关知识](#out)
`ref`和`out` 可以理解成 **他们也是一种变量类型** 所有可以用在重载中 但是`ref`和`out`**不能同时修饰**

```c#
static float Sum(ref float f,int a)
{
    return f+a;
}

//变长参数也可以用在重载中
static float Sum(int a, int b,params int[] c)
{
    return 1;
}
```

#### 练习题

重载一个函数
让其可以比较两个`int`或两个`float`或两个`double`的大小并返回较大的那个值

```c#
//int类型
static int Compare(params int[] arr)
{
    int max = arr[0];
    if (arr.Length==0)
    {
        Console.WriteLine("没有传入的参数");
        return 0;
    }
    for (int i = 0; i < arr.Length; i++)
    {
        //if (arr[i] > max)
        //{
        //    max = arr[i];
        //}
        max = arr[i]>max ? arr[i] : max;
    }

    Console.WriteLine("最大的数是:{0}",max);
    return max;
}
//float类型
static float Compare(params float[] arr)
{
    if (arr.Length == 0)
    {
        Console.WriteLine("没有传入的参数");
        return 0;
    }
    float max = arr[0];
    for (int i = 0; i < arr.Length; i++)
    {
        max = arr[i] > max ? arr[i] : max;
    }

    Console.WriteLine("最大的数是:{0}", max);
    return max;
}
//double类型
static double Compare(params double[] arr)
{
    if (arr.Length == 0)
    {
        Console.WriteLine("没有传入的参数");
        return 0;
    }
    double max = arr[0];
    for (int i = 0; i < arr.Length; i++)
    {
        max = arr[i] > max ? arr[i] : max;
    }
    Console.WriteLine("最大的数是:{0}", max);
    return max;
}
```

重载一个函数
让其可以比较n个`int`或n个`float`或n个`double`的大小并返回最大的那个值
(用`params`可变参数来完成)

```c#
//int类型
static int Compare(params int[] arr)
{
    int max = arr[0];
    if (arr.Length==0)
    {
        Console.WriteLine("没有传入的参数");
        return 0;
    }
    for (int i = 0; i < arr.Length; i++)
    {
        //if (arr[i] > max)
        //{
        //    max = arr[i];
        //}
        max = arr[i]>max ? arr[i] : max;
    }

    Console.WriteLine("最大的数是:{0}",max);
    return max;
}
//float类型
static float Compare(params float[] arr)
{
    if (arr.Length == 0)
    {
        Console.WriteLine("没有传入的参数");
        return 0;
    }
    float max = arr[0];
    for (int i = 0; i < arr.Length; i++)
    {
        max = arr[i] > max ? arr[i] : max;
    }

    Console.WriteLine("最大的数是:{0}", max);
    return max;
}
//double类型
static double Compare(params double[] arr)
{
    if (arr.Length == 0)
    {
        Console.WriteLine("没有传入的参数");
        return 0;
    }
    double max = arr[0];
    for (int i = 0; i < arr.Length; i++)
    {
        max = arr[i] > max ? arr[i] : max;
    }

    Console.WriteLine("最大的数是:{0}", max);
    return max;
}
```



---



### 递归函数

#### 基本概念

==**递归函数**== 就是 **让函数自己调用自己**
        

```c#
static void Fun()
{
    if (false)
    {
        return;
    }
    Fun();
}
```

<kbd>(上述代码为错误案例(没有结束))</kbd>

一个==正确==的**递归函数**
1.**必须有结束**调用的条件
2.**有**用于**条件判断的** 这个条件 **必须改变 能够达到停止的目的**

#### 实例

用递归函数打印出1到10
==递归函数== 就是 **让函数自己调用自己**

```c#
static void Fun(int a)
{
    //第四步:结束条件(终止递归)
    if (a > 10)
    {
        return;
    }
    //第二步:完成要求 打印
    Console.WriteLine(a);
    //第三步:完成一个 递归的变化 作为我们条件的判断
    a++;
    //第一步:构造一个递归
    Fun(a);
}
```

#### 练习题

##### 1.传入一个值 递归求该值的阶乘

并返回 如: 5! = 1 * 2 * 3 * 4 * 5
		  5! = 5 * 4 * 3 * 2 *1

```c#
static int Fun2(int i)
{
    if (i == 1)
    {
        return 1;
    }
    //return 5*4*3*2*1;
    return i * Fun2(i - 1);
    //5*Fun2(4) = 5*4*3*2*1;
    //4*Fun2(3) = 4*3*2*1;
    //3*Fun2(2) = 3*2*1;
    //2*Fun2(1) = 2*1;
    //1
}

Console.WriteLine(Fun2(6));
```

##### 2.使用递归求 1!+2!+3!+4!...+10!

结合 第二题

```c#
static int Fun3(int i)
{
    if (i == 1)
    {
        return Fun2(1);
        //return 1;
    }
    //10! + 9! + 8!...1!
    return Fun2(i) + Fun3(i - 1);
    //!10 + Fun3(9)
    //!9 + Fun3(8)
    //!8 + Fun3(7)
    //...
}

Console.WriteLine(Fun3(10));
```

##### 3.一根竹竿长100m 每天砍掉一半 求第十天它的长度是多少(从第0天开始)

```c#
static void Fun4( double l , int d = 0)//默认0天
{
    if (d > 10)
    {
        return;
    }
    Console.WriteLine("第{0}天 还剩{1}m", d, l);
    l /= 2;
    d++;
    Fun4(l, d);
}

Fun4(100);//100m d有默认值 所以可不填
```

##### 4.不允许使用循环语句 条件语句 在控制台中打印1~200这200个数(提示:递归+[短路](#短路))

```c#
static bool Fun5(int i = 1)
{
    Console.WriteLine(i);
    //if (i == 1)
    //{
    //    return false;
    //}
    return i >= 200 || Fun5(i+1);//有真则真 当前面的i>=200为真时 则 不执行后面的Fun5 
}
```



---



## 结构体



#### 总结:

==概念:==结构体 `struct` 是**变量和函数的集合** 用来表示特定数据的集合

**访问修饰符**:`public`和`private` 用来修饰变量和方法的 `public`**外部**可以调用 `private`**仅内部**使用 不写则**默认**是`private`
**结构函数**:**没有返回值** 函数名和结构名相同 **可以进行函数重载** 主要是帮助我们快速进行初始化结构体对象的

==注意:==
1.在结构体中声明的变量 **不能初始化** 只能在外部或者在函数中赋值(初始化)
2..在结构体中声明的函数 **不用**加`static`的

**结构体是值类型**



#### 基本概念

结构体 是一种**自定义变量类型** **类似枚举**需要自己定义
它是数据和函数的集合
在结构体中 可以声明各种变量和方法

==作用:==用来表现存在关系的**数据集合** 比如用结构体表现学生 动物 人类等等

#### 基本语法

1.结构体一般写在 `namespace`语句块中
2.结构体关键词 `struct`

```c#
struct 自定义结构体名字
{
    //第一部分
    //变量

    //第二部分
    //构造函数(可选)

    //第三部分
    //函数
}
```

==注意==: 构造体的**名字 规范** 是**帕斯卡命名法(首字母大写)** 

#### 访问修饰符

修饰结构体中变量和方法 <u>是否能够被外部使用</u>
`public` 公有的 **可以被外部访问**
`private` 私有的 只能在内容使用
**默认**不写 为`private`

#### 实例

创建一个关于学生的结构体

```c#
//创建一个关于学生的结构体
struct Student
{
    //变量
    //结构体声明的变量 不能够初始化
    //变量类型 可以写任意类型 包括结构体 但是不能是自己的结构体(可以是其他的)
    //Student s; //不能是自己的结构体
    //姓名
    public string name;
    //学号
    public int number;
    //年龄
    public int age;
    //性别
    public bool sex;
    
    //结构函数
    #region 知识点六 结构体的构造函数
    //基本概念
    //1.没有返回值
    //2.函数名必须和结构体名相同
    //3.必须有参数
    //4.如果声明了构造函数 那么必须在其中对所有变量数据初始化

    //构造函数 一般是用于在外部方便初始化的
    public Student(string name, int number, int age, bool sex)
    {
        //新关键字 this
        //this 代表自己
        this.name = name;
        this.number = number;
        this.age = age;
        this.sex = sex;
    }
    //构造函数也可以进行函数重载 但也必须进行初始化
    public Student(string name)
    {
        this.name=name;
        this.number = 0;
        this.age = 0;
        this.sex = false;
    }
    #endregion

    //函数方法
    //表现这个数据结构的行为

    //注意 在结构体中的方法 目前不需要加static关键字
    public void Speak()
    {
        //函数中可以直接使用结构体内部声明的变量
        Console.WriteLine("我的名字是{0},今年{1}岁", name, age);
    }
    //可以根据需求 写无数个函数
}
```

#### 构造函数

基本概念
1.**没有返回值**
2**.函数名必须和结构体名相同**
3.**必须有参数**
4.如果声明了构造函数 那么**必须将其中**对所有**变量数据初始化**

==构造函数== 一般是用于在**外部方便初始化**的

```c#
public Student(string name, int number, int age, bool sex)
{
    //新关键字 this
    //this 代表自己
    this.name = name;
    this.number = number;
    this.age = age;
    this.sex = sex;
}
```

构造函数**也可以**进行**函数重载** 但也**必须**进行**初始化**

```c#
public Student(string name)
{
    this.name=name;
    this.number = 0;
    this.age = 0;
    this.sex = false;
}
```

#### 结构体的使用

变量类型 变量名;

```c#
Student s1;
s1.name = "Xiao";
s1.age = 1;
s1.sex = true;
s1.number = 246622201;
s1.Speak();

Student s2 = new Student("yue",246622,18,false);
s2.Speak();
```



#### 练习题

##### 第一题:

使用结构体描述学员的信息 姓名 性别 年龄 班级 专业
创建两个学员对象 并对其基本信息进行初始化并打印

```c#
struct Student
{
    public string name;
    public string sex;
    public int age;
    public string room;
    public string discipline;

public Student(string name, string sex, int age,string room,string discipline)
{
    this.name = name;
    this.sex = sex;
    this.age = age;
    this.room = room;
    this.discipline = discipline;

    Console.WriteLine("姓名:{0} 性别:{1} 年龄:{2} 教室:{3} 专业:{4}",name,sex,age,room,discipline);
}

}
```

```c#
Student s1 = new Student("Xiao","男",19,"142","软件设计");
```

##### 第二题:

使用结构体描述矩形的信息 长宽高 创建一个矩形 对其长宽进行初始化
并打印矩形的长 宽 面积 周长等信息

```c#
struct Rectangle
{
    public int w;
    public int h;
    public Rectangle(int w,int h)
    {
        this.w = w;
        this.h = h;
        int area = w*h;
        int perimeter = 2*(w+h);
        Console.WriteLine("这个矩形 长:{0} 宽:{1} 面积:{2} 周长:{3}",w,h,area,perimeter);
    }
}
```

```c#
 Rectangle r = new Rectangle(3,3);
```

##### 第三题:

使用结构体描述玩家信息 玩家名称 玩家职业
请用户输入玩家姓名 选择玩家职业 最后打印玩家的攻击信息
职业:
战士(技能:冲锋)
猎人(技能:假死)
法师(技能:奥术冲击)
打印结果: 猎人XXX释放了假死

```c#
enum Profession//职业
{
    Warrior,
    Hunter,
    Mage,
}
struct Players
{
    public string name;
    public Profession profession;
    public Players(string name, Profession profession)
    {
        this.name = name;
        this.profession = profession;

        string pfs = "";
        string skill = "";

        switch (profession)
        {
            case Profession.Warrior:
                pfs = "战士";
                skill = "冲锋";
                break;
            case Profession.Hunter:
                pfs = "猎人";
                skill = "假死";
                break;
            case Profession.Mage:
                pfs = "法师";
                skill = "奥术冲击";
                break;
        }
        Console.WriteLine("{0}{1}释放了{2}",pfs,name,skill);
    }
}
```

```c#
Console.WriteLine("输入名字");
string name = Console.ReadLine();
Console.WriteLine("输入职业 0:战士 1:猎人 2:法师");
try
{
    int a = int.Parse(Console.ReadLine());
    Players py = new Players(name, (Profession)a);
    Console.WriteLine();
}
catch (Exception)
{
    Console.WriteLine("请输入数字");
}
```

##### 第四题:

使用结构体描述小怪物

```c#
struct Monster
{
    public string name;
    public int atk;
    public Monster(string name)
    {
        this.name = name;	
        Random r = new Random();//随机数值
        atk = r.Next(10,30);
    }
    public void Atk()
    {
        Console.WriteLine("{0}的攻击力是{1}",name,atk);
    }
}
```

定义一个数组存储10个上面描述的小怪物 每个小怪物的名字为(小怪物+数组下标)
列举:小怪物0 最后打印10个小怪物的名字 + 攻击力数值
变量类型[] 数组名 = new 变量类型[长度]

```c#
Monster[] monitors = new Monster[10];
for (int i = 0; i < monitors.Length; i++)
{
    monitors[i] = new Monster("小怪物" + i);
    monitors[i].Atk();
}
```

##### 第五题:

引用已学过的知识 实现超人打小怪物
提示:
结构体描述超人和小怪物
定义一个方法实现超人攻击小怪物
定义一个方法实现小怪物攻击超人

结构体是值类型 想要在函数内部改变值类型信息 外部受影响 要用 ref 或者 out

```c#
struct Man
{
    public string name;
    public int atk;
    public int def;
    public int hp;
    public Man(string name,int atk,int def,int hp)
    {
        this.name = name;
        this.atk = atk;
        this.def = def;
        this.hp = hp;
    }

    //超人打小怪物的逻辑
    public void Atk(ref Boss boos)
    {
        boos.hp -= atk - boos.def;
        Console.WriteLine("{0}攻击了{1} 造成了{2}点伤害 {3}的剩余血量为{4}点", name, boos.name, atk - boos.def, boos.name, boos.hp);
    }
}
struct Boss
{
    public string name;
    public int atk;
    public int def;
    public int hp;
    public Boss(string name, int atk, int def, int hp)
    {
        this.name = name;
        this.atk = atk;
        this.def = def;
        this.hp = hp;
    }
    //小怪物打超人的逻辑
    public void Atk(ref Man man)
    {
        man.hp -= atk - man.def;
        Console.WriteLine("{0}攻击了{1} 造成了{2}点伤害 {3}的剩余血量为{4}点",name,man.name, atk - man.def,man.hp,man.hp);
    }
}
```

```c#
Man man = new Man("Yue",20,10,520);
Boss boss = new Boss("jie", 15, 10, 250);
while (true)
{
    man.Atk(ref boss);
    if (boss.hp <= 0 )
    {
        Console.WriteLine("{0}胜利", man.name);
        break;
    }
    boss.Atk(ref man);
    if (man.hp <= 0)
    {
        Console.WriteLine("{0}胜利", boss.name);
        break;
    }
    Console.WriteLine("点任意键继续");
    Console.ReadKey(true);
}
```



---



## 排序

### 冒泡排序

#### 总结:

==基本概念:==             ==套路写法:==		==如何优化:==
两两相邻		  两层循环		 1,比过不比
不停比较		  外层轮次 		2.加入bool
不断交换		  内层比较
比较n轮		    两值比较
			         满足交换

#### 排序的基本概念

排序是计算机内经常进行的一种操作 其目的是**将一组"无序"**的记录序列**调整为"有序"**的记录序列
==常用的排序列子==
8 7 1 5 4 2 6 3 9
将上面的这个无序序列 **变成 有序(**升序或降序)序列的过程
1 2 3 4 5 6 7 8 9
9 8 7 6 5 4 3 2 1

在程序中 序列**一般 存储在数组当中**
所以 排序往往是对 数组进行排序

```c#
int[] arr = new int[] { 8, 7, 1, 5, 4, 2, 6, 3, 9 };
```

把数组里面的内容变为有序的

#### 冒泡排序的基本原理

两两比较
不停比较
不停交换
比较n轮
<img src="笔记图片/冒泡排序.gif" alt="冒泡排序" align="left" />















#### 代码实现

##### 第一步

**如何比较**数组中的两组**相邻的数**
8 7 1 5 4 2 6 3 9
从头开始
**第i个数** 和 **第n+1个数** 比较
==数组==是从0开始计算的 而==数组长度==是从1开始的 所以arr.Length需要 - 1

```c#
for (int i = 0; i < arr.Length-1; i++)//进一次循环就比较一轮
{
    //如果 第i个数 比第i+1个数大 那他们就要交换位置
    if (arr[i] > arr[i+1])
    {
        //第二步 交换位置
        //中间商 temp
        int temp = arr[i];
        arr[i] = arr[i+1];
        arr[i+1] = temp;
    }
}
```

##### 第三步

然后交换n轮?
有几个数(**数组长度**) 就交换多少轮

```c#
for (int n = 0;n < arr.Length;n++) 
{
     //进一次循环就比较一轮
     for (int i = 0; i < arr.Length-1; i++)
     {
         //如果 第i个数 比第i+1个数大 那他们就要交换位置
         if (arr[i] > arr[i + 1])
         {
             //第二步 交换位置
             //中间商 temp
             int temp = arr[i];
             arr[i] = arr[i + 1];
             arr[i + 1] = temp;
         }
     }
}
```

##### 第四步 优化

1.**确定**位置**的数字** **就不用在比较了**
确定了一轮 极值(最大或者最小) 已经放到对应位置了(往后放)
所以 **每完成n轮 后面位置的数 就不用在参与比较了** (让里面的循环再去减去外面的循环次数 `arr.Length - 1 - n`)

```c#
for (int n = 0; n < arr.Length; n++)
{
    //进一次循环就比较一轮
    for (int i = 0; i < arr.Length - 1 - n; i++)
    {
        //如果 第i个数 比第i+1个数大 那他们就要交换位置
        if (arr[i] > arr[i + 1])
        {
            //第二步 交换位置
            //中间商 temp
            int temp = arr[i];
            arr[i] = arr[i + 1];
            arr[i + 1] = temp;
        }
    }
}
```

2.特殊情况的优化
外面**声明**一个**标识** 来**表示 该轮是否进行了交换**

```c#
bool isSort = false;//标识
for (int n = 0; n < arr.Length; n++)
{
    //每一轮开始时 默认没有进行过交换
    isSort = false;
    //进一次循环就是比较一轮
    for (int i = 0; i < arr.Length - 1 - n; i++)
    {
        //如果 第i个数 比第i+1个数大 那他们就要交换位置
        if (arr[i] > arr[i + 1])
        {
            isSort = true;
            //第二步 交换位置
            //中间商 temp
            int temp = arr[i];
            arr[i] = arr[i + 1];
            arr[i + 1] = temp;
        }
    }
    //当一轮结束过后 如果isSort这个标识 还是false
    //那就意味着 已经是最终的序列了 不需要再判断交换了
    if (!isSort)
    {
        break;
    }
}
//效果展示
for (int i = 0; i < arr.Length; i++)
{
    Console.WriteLine(arr[i]);
}
```

#### 练习题

##### 第一题:

定义一个数组 长度为20 每个元素值随机0~100的数
使用冒泡排序进行升序排序并打印
使用冒泡排序进行降序排序并打印

```c#
Console.WriteLine("随机");
int[] arr = new int[20];
Random r = new Random();
//随机值
for (int i = 0; i < arr.Length; i++)
{
    arr[i] = r.Next(101);
    Console.Write(arr[i] + " ");
}
```

```c#
bool b = false;
for (int n = 0; n < arr.Length; n++)
{
    b = false;
    for (int i = 0; i < arr.Length - 1 - n; i++)
    {
        if (arr[i] > arr[i + 1])//将> 改成 < 就是降序
        {
            b = true;
            int temp = arr[i];
            arr[i] = arr[i + 1];
            arr[i + 1] = temp;
        }
    }
    if (!b)
    {
        break;
    }
}
//效果
for (int i = 0; i < arr.Length; i++)
{
    Console.Write(arr[i] + " ");
}
```

##### 第二题:

写一个[函数](#函数) 实现一个数组的排序 并返回结果 可以根据参数决定是升序还是降序

```c#
static int[] Sort(int[] array,bool Sort) 
{
    bool b = false;
    int temp;
    Console.WriteLine("当前是"+(Sort ? "升序" : "降序"));
    

for (int n = 0; n < array.Length; n++)
{
    b = false;
    for (int i = 0; i < array.Length - 1 - n; i++)
    {
        if (Sort ? (array[i] > array[i + 1]) : (array[i] < array[i + 1]))
        {
            b = true;
            temp = array[i];
            array[i] = array[i + 1];
            array[i + 1] = temp;
        }
    }
    if (!b)
    {
        break;
    }
}
return array;

}
```

```c#
//运用函数
Sort(arr, true);

//结果
for (int i = 0; i < arr.Length; i++)
{
    Console.Write(arr[i] + " ");
}
Console.WriteLine() ;
```



---



### 选择排序

#### 总结:

==基本概念:==
新建中间商
依次比较
找出极值
放入目标位置
比较n轮

==套路写法:==
两层循环
外层轮数
内层寻找
初始索引
记录极值
内存循环外交换

#### 1.选择排序基本原理

新建中间商
依次比较
**找出极值**(最大或最小)
**放入目标位置**
比较n轮

<img src="笔记图片/选择排序.gif" alt="选择排序" style="zoom: 50%;" align="left" />



#### 2.代码实现

实现升序 把最大值 放在最后面 

```c#
int[] arr = new[] { 10, 17, 1, 50, 14, 2, 6, 39, 90 };
```

##### 第一步

声明一个中间商 来记录索引
每一轮开始 都默认第一个数都是极值

```c#
int index = 0;
//第二步
//依次比较
for (int i = 0; i < arr.Length; i++)
{
    //第三步
    //找出极值(最大值)
    if (arr[index] < arr[i])
    {
        index = i;
    }
}
```

##### 第四步

放入 目标位置
Length - 1 -轮数
如果当前极值所在位置 就是目标位置 就没必要交换了

```c#
if (index != arr.Length - 1 - 轮数)
{
    //中间商
    int temp = arr[index];
    arr[index] = arr[arr.Length - 1 - 轮数];
    arr[arr.Length - 1 - 轮数] = temp;
}
```

##### 第五步

```c#
for (int n = 0; n < arr.Length; n++)
{
    //第一步 声明一个中间商 来记录索引
    //每一轮开始 都默认第一个数都是极值
    int index = 0;
    //第二步
    //依次比较

//arr.Length-n的目的是 排除上一轮 已经放好的位置的数
for (int i = 0; i < arr.Length - n; i++)
{
    //第三步
    //找出极值(最大值)
    if (arr[index] < arr[i])
    {
        index = i;
    }
}
//第四步 放入 目标位置
//Length - 1 -轮数
//如果当前极值所在位置 就是目标位置 就没必要交换了
if (index != arr.Length - 1 - n)
{
    //中间商
    int temp = arr[index];
    arr[index] = arr[arr.Length - 1 - n];
    arr[arr.Length - 1 - n] = temp;
}

}
//输出结果
for(int i = 0; i < arr.Length; i++)
{
    Console.Write(arr[i]+" ");
}
```



---



# C#核心

## 面向对象

### 面向对象概念

==作用:==

**提高**代码的复用性
**提高**开发效率
**提高**程序的扩展性
**清晰**的逻辑关系

==编程思想:==

面向对象编程思想就是:
万物皆对象
用程序来抽象(形容)对象
用面向对象的思想来编程

<img src="笔记图片/面向对象概念.png" style="zoom: 33%;" align="left"/>



---



### 类和对象

==总结==
**类的声明** 和 **类对象**的声明是<u>**两个概念**</u>
类的**声明 是**声明**对象的模版** 用来抽象(形容)**显示事物的**
类对象的声明 是用来表示现实中的 对象个体

类是一个**自定义**的**变量类型**
**实例化**一个**类对象** **就是**在**声明变量**

#### 基本概念

具有相同特征
具有相同行为
一类事物的抽象
类是对象的模版
可以通过类创建对象
类的关键词
`class`

类一般声明在namespace语句块中

#### 类声明的语法

```c#
 class 类名
 {
     //特征:成员变量
     //行为:成员方法
     //保护特征:成员属性
     
 	  //构造函数和析构函数
 	  //索引器
     //运算符重载
     //静态成员

 }
```

#### 什么是 (类) 对象

==基本概念==
类的声明 和 类对象(类变量)的声明是**两个概念**
类的声明 类似 枚举 和 结构体的声明 类的声明相当于声明了一个自定义的变量类型
而对象 是类创建出来的
相当于声明了一个指定类的变量
类创建对象的过程 一般称为实例化对象
==注意:==
**类对象 都是引用类型**

#### 实例化对象基本语法

```c#
//这个类表示人类
class Person
{

}

//这个类表示机器
class Machine

}
```

```c#
类名 变量名;
类名 变量名 = null;(null代表空)
类名 变量名 = new 类名();
```

```c#
Person p;
Person p2 = null;//null 代表空 不分配堆内存空间
Person p3 = new Person();//相当于一个人类对象
Person p4 = new Person();//相当于又是一个人类对象
```

==注意:==
虽然他们都是来着同一个类的实例化对象
但是他们的 特征 行为等等信息 都是他们独有的

```c#
Machine m = new Machine();
Machine m2 = new Machine();
```

**面向对象编程** 就是开启了 造物模式 想要什么对象 就new什么对象
一切的对象 都是由我们来控制的
我们相当于是整个程序世界的总导演

#### 练习题

```c#
![lesson01_类和对象_练习_第一题](笔记图片/lesson01_类和对象_练习_第一题.png)GameObject A = new GameObject();
GameObject B = A;
B = null;
//A目前等于多少?
//答: A = new GameObject();
```

```c#
GameObject A = new GameObject();
GameObject B = A;
B = new GameObject();
//A和B是什么关系?
//答:没有关系
```

<img src="笔记图片/lesson01_类和对象_练习_第一题.png" />



### 七大原则

**单一职责原则:**一个类<span style="color: red;">只处理自己应该处理的内容</span>,不应该啥都写在一起
**开闭原则:**对扩展开放,对修改封闭,<span style="color: red;">增加新功能尽量是加处理而不是改代码</span>
**里氏替换原则:**任何地方子类都能替代父类,<span style="color: red;">父类容器装子类</span>
**依赖倒转原则:**不要依赖具体的实现,要<span style="color: red;">依赖抽象(接口)</span>
**迪米特法则:**一个类要尽量减少对别的类的了解,<span style="color: red;">尽量少用别的类和自己关联</span>
**接口隔离原则:**一个接口一个行为,<span style="color: red;">不要一个接口n个行为</span>
**合成复用原则:**除非设计上需要继承,否则<span style="color: red;">尽量用组合复用的形式</span>

---

## 面向对象_封装

### 成员变量和访问修饰符

==总结==
成员变量
描述特征
类中声明
赋值随意
默认值 值不相同
默认值 引用为`null`
任意类型
任意数量

==访问修饰符==
`public` 公共 内外
`private` 私有的 内
`protected` 保护的 内和子类

#### 成员变量

==基本规则==
1.声明在类语句块中
2.用来描述对象的特征
3.可以是**任意的变量类型**(如 类 结构体 枚举等)
4.数量不做限制
5.是否赋值根据需求决定

```c#
//性别枚举
enum E_SexType
{
    Man,
    Woman,
}
//位置结构体
struct Position{}

//宠物类
class Pet
{

}

//人类
class Person
{
    //特征(成员变量)
    //姓名
    public string name = "张三";
    //年龄
    public int age;
    //性别
    public E_SexType sex;

    //如果要在类中声明一个和自己想通类型的成员变量时
    //不能对它进行实例化(初始化)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //女朋友
    public Person gridFriend;
    //朋友
    public Person[] boyFriend;
    //位置
    public Position pos;
    //宠物
    public Pet pet;
}
```

#### 访问修饰符

`public` 公共的 自己(内部)和别人(外部)都能访问和使用
`private` 私有的 自己(内部)才能访问和使用 不行 **默认**是`private`
`protected` 保护的 自己(内部)和子类才能访问和使用
目前决定类内部的成员的访问权限

#### 成员变量的使用和初始值

```c#
 Person p = new Person();
 //值类型 数字类型 默认都是0 bool类型 false
 //引用类型 null

 //看默认值的小技巧 default(变量类型)
 Console.WriteLine(default(string));

 p.age = 10;
 Console.WriteLine(p.name);
 Console.WriteLine(p.age);
```



---



### 成员方法

#### 总结
成员方法
描述行为
**类中声明**
**任意数量**
返回值和参数根据需求决定

#### 基本概念

成员方法(`函数`) 用来表现对象行为
1.**声明**在**类语句块中**
2.是用来描述对象的行为
3.**规则和函数声明规则相同**
4.**受到访问修饰符**规则**影响**
5.返回值参数不做限制
6.方法**数量不做限制**

==注意:==
1.成员方法不要加`static`关键词
2.成员方法 **必须实例化出对象** 在通过对象来使用 相当于该对象执行了某个行为
3.成员方法 受到访问修饰符影响

```c#
class Person
{
    public string name;
    public int age;
    //朋友们
    public Person[] friends;

/// <summary>
/// 说话的行为
/// </summary>
/// <param name="str">说话的内容</param>
public void Spea(string str)
{
    Console.WriteLine("{0}说{1}", name, str);
}

/// <summary>
///判断是否成年了 
/// </summary>
/// <returns></returns>
public bool IsAdult()
{
    return age >= 18;
}
/// <summary>
/// 添加新朋友方法
/// </summary>
/// <param name="p">新朋友</param>
public void Addfriend(Person p)
{

    if (friends == null)
    {
        friends = new Person[] { p };
    }
    else
    {
        //数组增加
        //新建一个 房子数组 
        Person[] newFriends = new Person[friends.Length + 1];
        //搬家
        for (int i = 0; i < friends.Length; i++)
        {
            newFriends[i] = friends[i];
        }
        //把新朋友放到数组最后一个
        newFriends[newFriends.Length - 1] = p;
        //地址重定向
        friends = newFriends;
    }
}
```

#### 成员方法的使用

成员方法 必须实例化出对象 在通过对象来使用 相当于该对象执行了某个行为

```c#
Person p = new Person();//实例化
p.name = "jie";
p.age = 18;
p.Spea("我爱你!");

if (p.IsAdult())
{
    Console.WriteLine("我要跟你玩!");
}

Person p2 = new Person();//实例化
p2.name = "Yue";
p2.age = 19;
//将p2 添加成我的新朋友
p.Addfriend(p2);
//打印我的朋友的信息
for (int i = 0; i < p.friends.Length; i++)
{
    Console.WriteLine(p.friends[i].name);
}
```

---

### 构造函数和析构函数(和垃圾回收)

#### 总结:

==构造函数==
实例化对象时 调用的函数
主要是用来初始化成员变量的
基本语法
不写返回值
函数名和类名相同
访问修饰符根据需求而定
一般为`public`
==注意:==
可以重构构造函数
可以用`this`语法重用代码
可以在函数中用this区分同名参数和变量
**有参构造会顶掉默认**的**无参构造**

==析构==当垃圾回收时 调用的 主要是用来回收资源或者特殊处理内存的
基本语法
**不写**返回值
**不写**修饰符
**不能**有参数
函数名和类名**一致**
类名前面加`~`



#### 基本概念

在**实例化对象时** 会调用的用于初始化的函数
如果不写 **默认会存**在**一个无参数构造函数**

==构造函数==的写法
1.没有返回值
2.函数名和类名**必须相同**
3.没有特殊需求时 一般都是`public`

```c#
    class Person
    {
        public string name;
        public int age;
        //类中是允许自己声明无参构造函数的
        //结构体是不允许的
        public Person() 
        {
            name = "Jie";
            age = 18;
        }        
       
        public Person(string name) 
        {
            this.name = name;
        }        
        public Person(int age) 
        {
            this.age = age;
        }
        //4.构造函数可以被重载
        public Person(string name,int age):this(age + 10)
        {
        //5.this代表当前调用函数里创建的对象自己
            this.name = name;
            this.age = age;
        }
        //当引用类型的堆内存被回收时 会调用该函数
        //析构函数 是当垃圾 真正被回收的时候 才会调用的函数
        ~Person()
        {

        }
    }



        Person p = new Person("Yue",18);
        Console.WriteLine(p.name);

        p = null;
```

==注意:==
如果不自己(写)实现无参构造函数而(写了)实现了有参构造函数
会**失去**默认的**无参构造**

#### 构造函数特殊写法

可以通过`this` 重用构造函数代码
访问修饰符 构造函数名(参数列表):this(参数1,参数2...)
**先执行this的函数** 然后在去执行 this前面的函数

```c#
public Person(string name, int age) : this(age + 10)
{

}
```

#### 析构函数

==基本概念==
当引用类型的堆内存被**回收时 会调用该函数**
对于需要手动管理内存的语言(如:C++) 需要在析构函数中做一些内存回收处理
但是C#中存在自动垃圾回收机制GC
所以我们激活不会怎么使用析构函数.除非你想在某一个对象**被垃圾回收时 做一些特殊处理**
==注意:==
在unity开发中析构函数几乎不会使用 了解即可

基本语法

```c#
~类名()
{

}
```

#### 垃圾回收机制

==垃圾回收== 英文简写 **GC(Garbage Collector)**
垃圾回收的过程是在遍历堆(`heap`)上动态分配的所有对象
通过识别它们是否被引用来确定哪些对象仍要被使用
所谓的**垃圾** 就是**没有被任何变量** 对象**引用的内容**
垃圾就需要被回收释放

**垃圾回收有很多算法**,比如
引用计数(Reference Counting)
标记清除(mark Sweep)
标记整理(Mark Compact)
复制集合(copy Collection)

==注意:==
**GC**只负责堆(Heap)内存的垃圾
引用类型都是存在堆(`Heap`)中的 所以它的分配和释放都通过垃圾回收机制来管理

栈(`Stack`)上的内存是由系统自动管理的
值类型在栈(`Stack`)中分配内存的 他们有自己的生命周期 不用对他们进行管理 会自动分配和释放

**C#中内存回收机制的大概原理**

**分代算法:**

<img src="笔记图片/分代算法.png" style="zoom:60%;" align="left" />

0代内存   1代内存   2代内存
代的概念:
代是垃圾回收机制使用的一种算法(**分代算法**)
新分配的对象都是被配置的第0代内存中
每次分配都可能会进行垃圾回收以释放内存(0代内存满时)

在一次内存回收过程开始时 垃圾回收器会认为堆中全是垃圾 会进行以下两步
1.标记对象 从根(静态字段 方法参数)开始检查 引用对象 标记后可达对象 未标记为不可达对象
 不可达对象就认为是垃圾
2.搬迁对象压缩堆 (挂起执行托管代码线程)释放释放未标记的对象 搬迁可达对象 修改引用地址

大对象总认为是第二代内存 目的是减少性能损耗 提高性能
不会对大对象进行搬迁压缩 85000字节(83kb)以上的对象为为大对象

==手动触发垃圾回收的方法==
一般情况下 不会频繁的调用
都是在**Loading过场景**时 才调用

```c#
GC.Collect();
```



---



### 成员属性

#### 总结:

1.**成员属性**的概念:一般**是**用来**保护成员变量**的
2.成员属性的使用和变量一样 外部用对象**点.**出
3.`get`中==输出==**return**内容   `set`中用**value**表示==输入==的内容
4.`get`和`set`语句块中**可以加逻辑处理**
5.`get`和`set`**可以加访问修饰符** 但是要按照一定的**规则**进行添加
6.`get`和`set`可以只要一个
7.==自动属性==可以是属性语句块中只有`get`和`set`,**一般用于 外部能得不能改的情况**

#### 基本概念

1.用于保护成员变量
2.为成员属性的获取和赋值**添加逻辑处理**
3.解决**3p的局限性**
`public` - 内外访问
`private` - 内部访问
`protected` - 内部和子类访问
属性可以**让成员变量在外部**
<u>只能获取 不能修改 或者 只能修改不能获取</u>

#### 基本语法

```c#
访问修饰符 属性类型 属性名
{
      get{}
      set{}
}
```

```c#
class Person
{
    private string name;
    private int age;
    private int money;
    private bool sex;

    //属性的命名一般使用帕斯卡命名法
    public string Name
    {
        get
        {
            //可以在返回之前添加一下逻辑规则
            //意味着 这个属性可以获取的内容
            return name;
        }
        set
        {
            //可以在设置之前添加一下逻辑规则
            //value 关键词用于表示 外部传入的值
            name = value;
        }
    }
```

#### get和set前面可以加访问修饰符

==注意:==
1.默认不加 **会使用属性声明时的访问权限**
2.**加的访问修饰符**要**低于属性的访问权限**
3.不能让get和set的权限都低于属性的权限 `public`权限是最高的

```c#
public int Money
{
   //get 加private 可以修改但不能访问
   private get
   {
       //解密处理
       return money-5;
   }
   //set 加private 能访问但不能修改
   set
   {
       //1.用于保护成员变量
       //加密处理
       //(如: 他人通过修改器修改数值时通过+5 存在内存的值就会+5 让其找不到自己所修改的值)
       //也可以通过其他加密算法进行加密
       money = value+5;
    //2.为成员属性的获取和赋值添加逻辑处理
    //if (value < 0)
    //{
    //    value = 0;
    //    Console.WriteLine("钱不能小于0");
    //}
    //money = value;
}
```

#### 成员属性的使用

```c#
 Person p = new Person();
 p.Money = 111;
 //Console.WriteLine(p.Money);
```

##### get和set可以只有一个

==注意:==
只有一个时 **没必要在前面加访问修饰符**
一般情况下 只会出现 只有get的情况 **基本不会出现只有set**

```c#
public bool Sex
{
    get
    {
        return sex;
    }
    //set
    //{ 
    //    sex = value;
    //}
}
```

#### 自动属性

==作用:==**外部能得不能改**的特征
如果类中有一个特征是只希望外部能得到不能改的 又**没有什么特殊处理**
那么可以直接使用自动属性

```c#
public float Height
{
    //没有get和set中写逻辑的需求或者想法
    get;
    private set;
}
```



---



### 索引器

#### 总结

索引器对于我们来说主要==作用==
可以让我们**以中括号的形式访问自定义类中的元素** 规则自己定 访问时**和数组一样**
比较适用于 在**类中有数组变量时**使用 可以**方便的访问**和**进行逻辑处理**

==固定写法==
访问修饰符 返回值 this[参数列表]
`get`和`set`语句块
可以重载
         
==注意==:**结构体**里面也一样是**支持索引器**

#### 基本概念

让对象可以**像数组一样**通过**索引访问其中元素** 使程序看起来更直观 更容易编写

#### 索引器基本语法

```c#
访问修饰符 返回值 this[参数类型 参数名,参数类型 参数名...]
{
      内部的写法和规则和索引器相同
      get{}
      set{}
}
```

```c#
class Person
{
    private string name;
    private int age;
    private Person[] friends;
    private int[,] array;
    
    #region 知识点五 索引器可以重载
    //重载的概念是 函数名相同 参数类型 数量 顺序不同
    //        就当this是函数名
    public int this[int i,int j]
    {
        get
        {
            return array[i,j];
        }
        set
        {
            array[i,j] = value;
        }
    }

    public string this[string str]
    {
        get
        {
            //通过索引来得到想要的值
            switch (str)
            {
                case "name":
                    return this.name;
                case "age":
                    return this.age.ToString();
            }
            return "";
        }
    }

    #endregion

    public Person this[int index]
    {

        get
        {
            //可以写逻辑的 根据需求来处理这里面的内容
            #region 知识点四 索引器中可以写逻辑
            //如果friends里面没有内容
            //并且朋友总数量(friends.Length-1)小于传进了的索引index
            //就直接返回空
            if (friends == null || friends.Length - 1 < index)
            {
                return null;
            }
            #endregion
            return friends[index];
        }
        set
        {
            //value代表传入的值
            //可以写逻辑的 根据需求来处理这里面的内容
            if (friends == null)
            {   
                //如果为空那就将传进来的那个人变成我的新朋友
                friends = new Person[] { value };
            }
            else if(index > friends.Length - 1)
            {
                //自己定了一个规则 如果索引器越界(传进来的index索引比friends[]数组的长度大)
                //就默认把friends[friends.Length - 1]最后一个朋友给替换成传进来的新朋友
                friends[friends.Length - 1] = value;
            }
            friends[index] = value;
        }
    }
}
```

#### 索引器的使用

```c#
Person p = new Person();
p[0] = new Person();
//p[0]得到的就是private Person[] friends里面的第一个朋友
Console.WriteLine("1111111"+p[0]);
```



---



### 静态成员

#### 总结:

==概念:==用`static`**修饰的成员变量** 成员方法 成员属性等 就称为**静态成员**
==特点:==直接用类名点出来使用(**全局性**)
==生命周期:==和程序同生共死(程序运行后会一直存在内存中 直到程序结束后才会释放 因此静态成员具有**唯一性**)
==注意:==
1.静态函数中不能直接使用非静态成员
2.非静态函数可以直接使用静态成员

==常量和静态变量==
常量是特殊的静态变量
相同点
他们都可以通过类名点出来使用
==不同点==
1.`const`必须初始化不能被修改 `static`没有这个规则
2.`const`只能修饰变量 `static`可以修饰很多
3.`const`不会写在访问修饰符前面 一定是写在变量声明钱 `static`没有这个规则

#### 基本概念

**静态关键词** `static`
用`static`修饰的 成员变量 方法 属性等
称为静态成员

静态成员的特点是:**直接用类名点出使用**

#### 自定义静态成员

```c#
class Test
{
    //静态成员变量
    public static float PI = 3.1416926f;
    //成员变量
    public int testInt = 100;

    //public 和 static 位置可以互相交换

    //静态成员方法
    static public float CalcCircle(float r)
    {
        #region 知识点六 静态函数中不能使用非静态成员
        //成员变量只能将对象实例化出来后 才能点出来使用 不能无中生有
        //不能直接使用 非静态成员 否则会报错(只能先实例化才能使用)
        //testInt
        Test test = new Test();
        Console.WriteLine(test.testInt);
        #endregion
        //πr²
        return PI * r * r;
    }
    //成员方法
    public void TestFun()
    {
        Console.WriteLine("123");
        #region 知识点七 非静态函数中可以使用静态成员
        Console.WriteLine(PI);
        Console.WriteLine(CalcCircle(2));
        #endregion
    }

}
```

#### 静态成员的使用

```c#
//静态
Console.WriteLine(Test.PI);
Console.WriteLine(Test.CalcCircle(2));

//非静态
Test t = new Test();
Console.WriteLine(t.testInt);
t.TestFun();
```

#### 为什么可以直接点出来使用

==记住!==
程序中是**不能无中生有**的
我们要使用的对象 变量 函数**都是**要在**内存中分配空间**的
之所以要实例化对象 目的就是分配内存空间 在程序中产生一个抽象的对象

==静态成员的特点==
程序开始运行时 就会分配内存空间 所以我们就能直接使用
**静态成员和程序同生共死**
只要使用了它 直到**程序结束时**内存空间**才会被释放**
所以一个静态成员就会有自己唯一的一个"内存小房间"
这让静态成员有了**唯一性**
在任何地方使用都是用小房间里面的内容 改变了它也是改变小房间的内容

#### 静态成员对于我们的作用

==静态变量:==
1.**常用**唯一的声明
2**.方便**别人**获取**的**对象声明**
==静态方法==
常用的唯一的方法声明 比如 相同规则的数学计算相关函数

#### 常量和静态变量

`const`(常量)可以理解为特殊的`static`(静态)
==相同点==
他们都可以通过**类名点出来使用**
==不同点==
1.`const`必须初始化 不能修改 `static`没有这个规则
2.`const`只能修饰变量 `static`可以修饰很多
3.`const`一定是写在访问修饰符后面的 `static`没有这个要求

#### 单例模式

```c#
class Test
{
    private static Test instance = new Test();
    private Test() { }
    public static Test Instance
    {
        get { return instance; }
    }
    public int v;
}
```

```c#
//直接点出使用
Test.Instance.v = 1;
```



### 静态类和静态构造函数

#### 总结

==静态类:==
用`static` 修饰的类
==特点:==
只能包含静态成员
不能实例化
==作用:==
使做工具类
拓展方法

==静态构造函数:==
用`static`修饰的构造函数
==特点:==
静态类和普通类都可以有静态构造函数
不能使用访问修饰符
不能有参数
只会**自动调用一次**
==作用:==
初始化静态成员

#### 基本概念

用`static`修饰的类

==特点:==
只能包含静态成员
不能被实例化

==作用==
1.将常用的静态成员写在静态类中 方便使用
2.静态类不能实例化 更能体现工具类的 唯一性
比如`Console`就是一个静态类

```c#
static class TestStatic
{
    //静态成员变量
    public static int testIndex = 111;
    //静态成员方法(函数)
    public static void TestFun()
    {

    }
    //静态成员属性
    public static int TestIndex
    {
        get;
        set;
    }
}
```

#### 静态构造函数

在构造函数加上`static`修饰

==特点:==
1.静态类和普通类**都可以有**
2.**不能**使用访问修饰符
3.**不能**有参数
4.**只会自动调用一次**(使用类的时候自动最先调用静态构造函数)

==作用:==
在静态类构造函数中初始化 静态变量

==使用:==
1.静态类中的静态构造函数

```c#
static class StaticClass
{
    public static int testInt = 100;
    public static int testInt2 = 200;
    //静态构造函数
    static StaticClass()
    {
        Console.WriteLine("静态构造函数");
        testInt = 200;
        testInt2 = 300;
    }
}
//2.普通类中的静态构造函数
class Test
{
    public static int testInt = 100;
    static Test()
    {
        Console.WriteLine("静态构造函数");
    }
    public Test()
    {
        Console.WriteLine("普通构造函数");
    }
}
```



---



### 拓展方法

#### 总结:
==概念:==为现有的非静态 变量类型 添加方法
==作用:==
**提升程序拓展性**
不需要在对象中重新写方法
不需要继承来添加方法
为别人封装的类型写额外的方法

==特点:==
静态类中的静态方法
第一个参数 代表拓展的目标
第一个参数前面一定要加 `this`

==注意:==
可以有返回值 和 n个参数
根据需求而定

#### 基本概念

为现有非静态 变量类型 添加 新方法
==作用:==
1.**提高程序拓展性**
2.**不需要**在对象中**重新写方法**
3.不需要基础来添加方法
4.**为别人封装的类型写额外的方法**
==特点:==
1.**一定**是写**在静态类中**
2.**一定**是个**静态函数**
3.**第一个参数为拓展目标**
4.第一个参数用`this`**修饰**

#### 基本语法

访问修饰符 static 返回值 函数名(this 拓展类名 参数名,参数类型 参数名,参数类型 参数名...)

```c#
static class Tools
{
    //为int拓展了一个成员方法
    //成员方法 是需要 实例化后 才能使用的
    //value 代表 使用该方法的 实例化对象
    public static void SpeakValue(this int value)
    {
        //拓展的方法的逻辑
        Console.WriteLine("为int拓展的方法"+value);
    }
    //为string拓展了一个成员方法
    public static void SpeakStringInfo(this string str,string str2,string str3)
    {
        //拓展的方法的逻辑
        Console.WriteLine("为string拓展的方法");
        Console.WriteLine("调用方法的对象:"+str);
        Console.WriteLine("传的参数:"+str2+str3);
    }
    //为Test拓展了一个成员方法
    public static void Fun3(this Test t)
    {
        Console.WriteLine("为Test拓展的方法");
    }
}
```

#### 为自定义的类型拓展方法

```c#
class Test
{
    public int i = 10;
    public void Fun1()
    {
        Console.WriteLine("123");
    }
    public void Fun2()
    {
        Console.WriteLine("456");
    }
}
```

#### 如何使用

```c#
int i = 10;
//int本来是没有的 但我们为它拓展了SpeakValue
i.SpeakValue();
Tools.SpeakValue(100);

string str = "000";
str.SpeakStringInfo("111", "222");

Test test = new Test();
test.Fun3();
```



---



### 运算符重载

#### 总结:

关键词:`operatir`
==固定写法:==
public static 返回值 operator 运算符(参数列表)
==作用:==
让**自定义类**或者**结构体对象** 进行**运算**
==注意:==
1.参数的数量
2.条件运算符的**配对实现**
3.一个符号可以**多个重载**
4.**不能**使用`ret`和`out`

#### 基本概念

让**自定义类**和**结构体**
能够**使用运算符**

使用**关键词**
`operator`

==特点:==
1.一定是一个**公共的静态方法**
2.返回值写在`operator`前面
3.逻辑处理自定义

==作用:==
让自定义类和结构体对象可以进行运算

==注意:==
1.条件运算符需要成对实现  相关符号必须**配对实现**
(如:使用了>运算符也必须使用<运算符)
2.一个符号可以**重载多个**
3.**不能**使用`ref`和`out`

#### 基本语法

public static 返回类型 operator 运算符(参数列表)

```c#
class Point
{
    public int x;
    public int y;
    public static Point operator +(Point p1,Point p2)
    {
        Point p = new Point();
        p.x = p1.x + p2.x;
        p.y = p1.y + p2.y;
        return p;
    }
    //重载
    public static Point operator +(Point p1, int i)
    {
        Point p = new Point();
        p.x = p1.x + i;
        p.y = p1.y + i;
        return p;
    }
    public static Point operator +(int i, Point p1)
    {
        Point p = new Point();
        p.x = p1.x + i;
        p.y = p1.y + i;
        return p;
    }

}
```

#### 运算符重载的使用

```c#
Point p= new Point();
p.x = 1;
p.y = 1;
Point p2 = new Point();
p2.x = 2;
p2.y = 2;

Point p3 = p + p2;
//重载
Point p4 = p + 2;
p4 = 2 + p ;
```

#### 可重载和不可重载的运算符

==可重载的运算符:==
算数运算符
逻辑运算符
位运算符
条件运算符

==不可重载的运算符:==
逻辑与(&&) 逻辑或(||)
索引符[]
强转运算符()
特殊运算符
点.  三目运算符 ? :   赋值运算符=



---

### 内部类和分部类

#### 内部类

==概念:==
**在一个类中声明一个类**
==特点:==
使用时要用包裹者**点出自己**
==作用:==
亲密关系的变现
==注意:==
访问修饰符作用很大

```c#
class Person
{
    public int age;
    public string name;
    public Body body;
    public class Body
    {
        Arm leftArm;
        Arm rightArm;
        class Arm
        {

    	  }
	}
}
```

使用时要用包裹者**点出自己**

```c#
Person p = new Person();
Person.Body body = new Person.Body();
```

#### 分部类

==概念:==
把**一个类分成几部分**声明
==关键词:==`partial`
==作用:==
分部描述一个类
增加程序的拓展性
==注意:==
分部类可以写在多个脚本文件中
分部类的访问修饰符**要一致**
分部类中**不能有重复成员**

```c#
partial class Student
{
    public bool sex;
    public string name;
    //分部方法
    partial void Speak();
}
partial class Student
{
    public int number;
    public void Speak(string str)
    {

    }
    //分部方法
    partial void Speak()
    {
        //分部实现
    }
}
```

#### 分部方法

==概念:==
将方法的声明和实现分离
==特点:==
1.**不能加访问修饰符** 默认私有
2.**只能**在**分部类中声明**
3.返回值只能是`void`
4.可以**有参数**但不用 `out`关键词

局限性大 <kbd>了解即可</kbd>



---



## 面向对象_继承

### 继承的基本规则

#### 总结:

==继承基本语法==:
class 类名 : 父类名{}
1.**单根性**:只能继承一个父亲
2.**传递性**:子类可以继承父类的父类...的所有内容
3.访问修饰符 对于成员的影响

4.<kbd>极其不建议使用</kbd> 在子类中声明和父类同名的成员(以后学习[多态](#多态)会解决这个问题)

#### 基本概念

一个类A继承一个类B
类A**将会继承**类B的**所有成员**
A类将拥有B类的**所有特征和行为**
==被继承的类==
称为 父类 基类 超类
==继承的类==
称为子类 派生类
子类**可以有自己的特征和行为**
==特点==
1.**单根性** 子类**只能有一个父亲**
2.**传递性** 子类**可以间接继承父类的父类**

#### 基本语法

```c#
class 类名 : 被继承的类名
{

}
```

<img src="笔记图片/父类继承.png" alt="父类继承" style="zoom:50%;" />

```c#
//老师类
class Teacher
{
    //姓名
    public string name;
    //职工号
    protected int number;
    //介绍自己
    public void SpeakName()
    {
        number = 10;
        Console.WriteLine("我叫"+name);
    }
}
//教学老师类 : 继承老师类
class TeachingTeacher : Teacher
{
    //科目
    public string subject;
    //介绍科目
    public void SpeakSunbject()
    {
        number = 11;
        Console.WriteLine("我是{0}老师", subject);
    }
}
//语文老师 : 继承教学老师类
class ChineseTeacher : TeachingTeacher
{
    //技能
    public void Skill()
    {
        Console.WriteLine("我会教学语文课程");
    }
}
```

```c#
//使用
TeachingTeacher tt = new TeachingTeacher();
tt.name = "Yue";
//tt.number = 114514;
tt.SpeakName(); 

tt.subject = "C#";
tt.SpeakSunbject();

Console.WriteLine("------华丽分割线------");

ChineseTeacher ct = new ChineseTeacher();
ct.name = "Jie";
//ct.number = 1008611;
ct.subject = "语文";
ct.SpeakName();
ct.SpeakSunbject();
ct.Skill();
```

#### 访问修饰符的影响

`public` - **公共** 内外部访问
`private` - 私有 内部访问
`protected` - **保护** 内部和子类访问

之后讲==命名空间==的时候讲
`internal` - 内部的 只有在同一个程序集的文件中 内部类型或者是成员才可以访问

#### 子类和父类的同名成员

==概念:==
C#中允许子类存在和父类同名的成员
但是 **极不建议使用**



---



### 里氏<span id="里氏替换">替换</span>原则

#### 总结:

==概念:==**父类容器装子类对象**
==作用:==方便进行对象的存储和管理
==使用:==`is` 和 `as`
`is`用于**判断**
`as`用于**转换**
==注意:==**不能**用**子类**容器**装父类**对象

#### 基本概念

==里氏替换原则==是面向对象 **七大原则中最重要的原则**
==概念:==
任何**父类出现的地方** **子类都可以替代**
==重点:==
语法表现 - **父类容器装子类对象** **因为子类对象包含了父类的所有内容**
==作用:==
**方便**进行对象**存储和管理**

#### 基本实现

```c#
class GameObject
{

}

class Player : GameObject
{
    public void PlayerAtk()
    {
        Console.WriteLine("玩家攻击");
    }
}
class Monster : GameObject
{
    public void MonsterAtk()
    {
        Console.WriteLine("怪物攻击");
    }
}
class Boos : GameObject
{
    public void BoosAtk()
    {
        Console.WriteLine("Boos攻击");
    }
}
```

**里氏替换原则 用父类容器 装载子类对象**

```c#
GameObject player = new Player();
GameObject monster = new Monster();
GameObject boos = new Boos();

GameObject[] objects = new GameObject[] { new Player(),new Monster(),new Boos() };
```



#### is和as

==基本概念:==
`is`:**判断**一个对象**是否是指定类对象**
**返回值:bool** 是为真 不是为假

`as`:将一个对象**转换为指定对象**
**返回值:指定类型对象**
返成功返回指定类型对象 **失败返回bull**

==基本语法==
类对象 `is` 类名  该语句块 会有一个`bool`返回值 `true`和`false`
类对象 `as` 类名  该语句块 会有一个对象返回值 对象和`null`

```c#
if(player is Player)
{
    //Player p = player as Player;
    //p.PlayerAtk();
    //简写:
    (player as Player).PlayerAtk();
}

for(int i = 0;i < objects.Length; i++)
{
    if (objects[i] is Player)
    {
        (objects[i] as Player).PlayerAtk();
    }
    else if (objects[i] is Monster)
    {
        (objects[i] as Monster).MonsterAtk();
    }
    else if (objects[i] is Boos)
    {
        (objects[i] as Boos).BoosAtk();
    }
}
```



---



### 继承中的构造函数

#### 总结:

继承中的构造函数
==特点:==
**执行顺序** 先执行父类的构造函数 在执行子类的(从老祖宗开始 **依次一代一代向下执行**)

**父类**中的**无参构造很重要**
**如果被顶掉** **子类就无法默认调用**无参构造了
==解决方法:==
1.**始终**保持**声明一个无参构造**
2.通过`base`关键词 **调用指定的父类构造**
==注意:==
区分`this`和`base`的区别

#### 基本概念

 ==特点:==
 先声明一个子类对象时
 先执行父类的构造函数
 在执行子类的构造函数

 ==注意:==
 1.**父类**的**无参构造**函数 **很重要**
 2.**子类**可以通过`base`关键字 **代表父类 调用父类构造**

#### 继承中构造函数的执行顺序

父类的父类的构造函数 ---> 父类的构造 -->...--->子类的构造函数

```c#
class GameObject
{
    public GameObject()
    {
        Console.WriteLine("1.GameObject的构造函数");
    }
}
class Player:GameObject
{
    public Player()
    { 
        Console.WriteLine("2.Player的构造函数");
    }
}
class MainPlayer : Player
{
    public MainPlayer()
    {
        Console.WriteLine("3.MainPlayer的构造函数");
    }
}
```

```c#
//父类的父类的构造函数 ---> 父类的构造 -->...--->子类的构造函数
MainPlayer mainPlayer = new MainPlayer();
```

#### 父类的无参构造函数(重要)

**子类实例化**时 **默认**自动**调用**的 是**父类的无参构造** 所以**如果父类无参构造被顶掉 会报错**

```c#
class Father
{
    //public Father()
    //{

	 //}
    public Father(int i)
    {
        Console.WriteLine("Father的构造");
    }
}

class Son : Father
{
    #region 知识点四 通过base调用指定父类的构造(没有默认调用无参构造)
    public Son(int i) : base(i)
    {
        Console.WriteLine("Son的第一个参数的构造");
    }
    #endregion
    public Son(int i,string str) : this(i)
    {
        Console.WriteLine("Son的第二个参数的构造");
    }
}
```

```c#
Son s = new Son(1,"1");
```



---



### 万物之父和装箱拆箱

#### 总结

==万物之父:==`object`
基于[里氏替换](#里氏替换)原则的 可以用`object`容器**装载一切**类型的**变量**
**它是所有类型的基类**

==装箱拆箱==
用`object`存储值类型(装箱)
把`object`里面存的值 转换出来(拆箱)

**好处:**
不确定类型时可以使用 **方便参数存储和传递**

**坏处:**
存在内存的迁移 **增加性能消耗**

不是不用 尽量少用

#### 万物之父

万物之父
关键词:`object`
==概念:==
`object` 是**所有类型的基类** 他是一个**类(引用类型)**
==作用:==
1.可以利用[里氏替换](#里氏替换))原则 用`object`容器装所有对象
2.可以用来表示不确定类型 作为函数参数类型

#### 万物之父的使用

```c#
class Father
{

}
class Son : Father
{
    public void Speak()
    {
        Console.WriteLine("说话");
    }
}
```

```c#
Father f = new Son();
if(f is Son)
{
    (f as Son).Speak();//说话
}
//引用类型
object o = new Son();
//用is as 来判断和转换即可
if (o is Son)
{
    (o as Son).Speak();
}
//值类型
object o2 = 114514;
//用强转
int i = (int)o2;
//特殊的string类型
object str = "123";
string str2 = str.ToString();
str2 = str as string;

//数组
object arr = new int[10];
int[] arr2 = (int[])arr;
arr2 = arr as int[];
```

####  装箱拆箱

**发生条件**
用`object`**存值类型**(装箱)
再把`object`**转为值类型**(拆箱)

**装箱**
把**值类型用引用类型存储**
**栈内存会迁移到堆内存中**

**拆箱**
把**引用类型存储的值类型取出来**
**堆内存会迁移到栈内存中**

==好处:==不确定类型时可以**方便参数的存储和传递**
==坏处:==存在内存迁移 增加**性能消耗**

```c#
//装箱
object v = 1;
//拆箱
int intValue = (int)v;
```

<img src="笔记图片/万物之父object装箱拆箱.png" align="left" style="zoom: 33%;" />

**好处 如:**不确定类型时可以**方便参数的存储和传递**

```c#
static void TestFun(params object[] array)
{

}
//好处:如
TestFun(1, 2, 3, 4f, 3.5, "123", new Son());
```



----



### <span id="密封类">密封类</span>

#### 总结

==关键词==:`sealed`
==作用:==**让类无法再被继承**
==意义:==加强面向对象程序设计的 规定性 结构性 安全性

#### 基本概念

**密封类** 是使用 `sealed`密封关键字修饰的类
==作用:==**让类无法再被继承**

#### 实例

```c#
class Father
{

}
//加了sealed就等于断子绝孙了 无法再被继承
sealed class Son:Father
{ 
    
}
```

#### 作用

在面向对象程序的设计中 密封类的**主要作用就是不允许最底层子类被继承**
可以**保证程序的规范性 安全性**
目前对大家来说 可能用处不大
**制作复杂系统或者程序框架时 便能体会到密封的作用**



---



## 面向对象_多态

### Vob

#### 总结:

==多态:==让**同一类型的对象** **执行相同行为时有不同的表现**
==解决的问题:==让**同一个对象有唯一的行为特征**
`virtual` **虚函数**
`override` **重写**
`base` **父类**
v和o一定是结合使用的 来实现多态
b是否使用根据实际需求 保留父类行为

#### 多态的概念

多态按字面的意思就是"**多种状态**"
让**继承同一父类的子类们** 在**执行相同方法时有不同的表现**(状态)
==主要目的==
同一父类的对象 **执行相同行为(方法)有不同的表现**
==解决的问题==
**同一个对象有唯一的行为特征**

#### 解决的问题

```c#
class Father
{
    public void Speak()
    {
        Console.WriteLine("父类的方法");
    }
}
class Son:Father
{
    public void Speak()
    {
        Console.WriteLine("子类的方法");
    }
}
```

```c#
Father f = new Son();
f.Speak();//父类的方法

(f as Son).Speak();//子类的方法
```

#### 多态的实现

我们目前已学过的多态了
编译时多态-**函数重载** 开始就写好的

==我们将学习的:==
运行时多态(vob 抽象函数 接口)
**vob**
v:`virtual`(<span id="虚函数">**虚函数**</span>)
o:`override`(**重写**)
b:`base`(**父类**)

```c#
class GameObject
{
    public string name;
    public GameObject(string name)
    {
        this.name = name;
    }
    //virtual虚函数 可以被之类重写
    public virtual void Atk() 
    {
        Console.WriteLine("游戏对象进行攻击");
    }
}

class Player : GameObject
{
    public Player(string name) : base(name)
    {

    }
    //override重写虚函数
    public override void Atk()
    {
        //base的作用:
        //代表父类 可以通过base来保留父类的行为
        base.Atk();//执行父类的方法
        Console.WriteLine("玩家对象进行攻击");
    }
}
class Monster : GameObject
{
    public Monster(string name):base(name)
    {

    }
    public override void Atk()
    {
        Console.WriteLine("怪物对象进行攻击");
    }
}
```

```c#
GameObject p = new Player("Yue");
p.Atk();//玩家对象进行攻击
(p as Player).Atk();//玩家对象进行攻击

GameObject m = new Monster("怪物");
m.Atk();//怪物对象进行攻击
(m as Monster).Atk();//怪物对象进行攻击
```



---



### 抽象类和抽象方法

#### 总结

==抽象类:== 被`abstract`修饰的类 **不能被实例化** **可以包含抽象方法**
==抽象方法:== 没有方法体的**纯虚方法** **继承后必须去实现**的方法
==注意:==
**如何选择普通类还是抽象类**(==作用:==)
不希望被实例化的对象 相对比较抽象的类可以使用抽象类
父类中的行为不太需要被实现的 只希望子类去定义具体的规则的 可以选择 抽象类然后使用其中的抽象方法来定义规则
==作用:==
整体框架设计时 会使用

#### <span id="抽象类">抽象类</span>

==概念:==
被抽象关键字`abstract`**修饰的类**
==特点:==
1.**不能被实例化**(但是可以**遵循里氏替换原则** **用父类容器装子类**)
2.**可以包含抽象方法**
3.**继承抽象类必须重写其抽象方法**

```c#
abstract class Thing
{
    //抽象类中 封装的所有知识点都可以在其中书写
    public string name;
    //可以在抽象类中写抽象方法
}
class Water:Thing 
{ 
    
}
```

```c#
//抽象不能被实例化
//Thing t = new Thing();
//但是 可以遵循里氏替换原则 用父类容器装子类
Thing t = new Water();
```

#### 抽象方法

纯虚方法
用`abstract`关键字修饰的方法
==特点:==
1.**只能**用**在抽象类中声明**
2.**没有方法体{}**
3.**不能**是**私有**的
4.**继承**后**必须实现** 用`override`重写

```c#
abstract class Fruits
{
    public string name;
    //抽象方法 是一定不能有函数体{}的
    public abstract void Bad();
    //虚方法
    public virtual void Test()
    {
        //可以选择是否写逻辑
    }
}
class Apple : Fruits
{
    //继承后必须实现用override重写
    public override void Bad()
    {
        
    }
}
class SuperApple : Apple
{
    //虚方法和抽象方法 都可以被子类无限的 去重写
    public override void Bad()
    {
        base.Bad();
    }
    public override void Test()
    {
        base.Test();
    }
}
```



---



### <span id="接口">接口</span>

#### 总结

[继承类](#继承类):是**对象间的继承** 包括特征行为等等
==继承接口:==是**行为间的继承** 继承接口的行为规范 按照规范去实现内容
由于**接口**也是**遵循里氏替换原则** 所以**可以用接口容器装对象**

==注意:==
1.接口值**包含** **成员方法** **属性** **索引器** **事件** 并且**都不实现 都没有访问修饰符**
2.可以**继承多个接口** 但是**只能继承一个类**
3.**接口可以继承接口** **相当于**在进行**行为合并** **待子类继承时**再去**实现具体的行为**
4**.接口可以被显示实现** 主要用于实现不同接口中的同名函数的不同表现
5.**实现的接口** 可以加`virtual`关键字 **之后子类 在重写**

#### 接口的概念

**接口是行为的抽象规范**
它也是一个**自定义类型**
==关键词:==`interface`

接口声明的==规范:==
1.**不包含成员变量**
2.**只包含方法 属性 索引器 事件**
3.**成员不能被实现**
4.成员可以不用写访问修饰符 **不能是私有的**
5.**接口不能继承类** 但是**可以继承另一个接口**

接口的使用==规范==
1.**类可以继承多个接口**
2.**类继承接口后 必须实现接口中的所有成员**

==特点:==
1.它和类的声明类似
2.接口是用来继承的
3.接口**不能被实例化** 但是**可以作为容器存储对象**

#### 接口的声明

**接口关键字**:`interface`
==语法:==

```
interface 接口名
{

}
```

一句话记忆:接口是一个**抽象行为的"基类"**
**接口命名规范 帕斯卡前面加"I"**

```c#
interface IFly
{
    //方法
    void Fly()
    {

    }
    //属性
    string Name
    {
        get;
        set;
    }
    //索引
    int this[int index]
    {
        get;
        set;
    }
    //事件
    event Action doSomthing;
}
```

#### 接口的使用 

```c#
    //接口用来继承
    class Animal
    {

    }
    //1.类可以继承1个类,n个接口
    //2.继承了接口后 必须实现其中的内容 并且必须是public的
    class Person : Animal, IFly
    {
        //3.实现的接口函数 可以加virtual再在子类重写
        //方法
        public virtual void Fly()
        {

        }
        //属性
        public string Name
        {
            get;
            set;
        }
        //索引
        public int this[int index]
        {
            get
            {
                return 0;
            }
            set
            {

            }
        }
        //事件
        public event Action doSomthing;
    }
    //4.接口也遵循里氏替换原则
```

```c#
 //4.接口也遵循里氏替换原则
 IFly f = new Person();
```

#### 接口可以继承接口

```c#
//接口继承接口时 不需要实现
//待类继承接口后 类自己去实现所有内容
interface IWalk
{
    void Walk();
}
interface IMove : IFly, IWalk
{

}
//类继承接口后 类自己去实现所有内容
class Test : IMove
{
    public int this[int index] { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }

    public string Name { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }

    public event Action doSomthing;

    public void Walk()
    {
        throw new NotImplementedException();
    }
}
```

```c#
 //4.接口也遵循里氏替换原则
IMove im = new Test();
IFly ifly = new Test();
IWalk iw = new Test();
```

#### 显示实现接口

当**一个类继承两个接口**
**但是接口**中**存在着同名方法时**
==注意:==显示实现接口时 不能写访问修饰符

```c#
interface IATk
{
    void Atk();
}
interface ISuperAtk
{
    void Atk();
}
class Player : IATk, ISuperAtk
{
    //显示实现接口 就是用 接口名:行为名 去实现
    void IATk.Atk()
    {
        
    }
    void ISuperAtk.Atk()
    {
        
    }
    public void Atk()
    {

    }
}
```

```c#
Player p = new Player();
(p as IATk).Atk();
(p as ISuperAtk).Atk();
```



---



### 密封方法

#### 基本概念

用**密封关键字**`sealed` 修饰的重写函数
==作用:== **让虚方法**或者**抽象方法之后不能再被重写**
==特点:== 和`override`一起出现

#### 实例

```c#
//动物抽象类
abstract class Animal
{
    public string name;
    public abstract void Eat();//抽象方法
    public virtual void Speak()//虚方法
    {
        Console.WriteLine("叫");
    }
}
//人类
class Person : Animal
{
    public override void Eat()
    {
        
    }
    public override void Speak()
    {

    }

}
//白人类
class WhitePerson : Person
{
    public override void Eat()
    {
        base.Eat();
    }
    public sealed override void Speak()//写了selea 后面就不能在重写了
    {
        base.Speak();
    }
}
```



---

## 面向对象_相关

### 命名空间

#### 总结

1.**命名空间是个工具包** **用来管理类的**
2.**不同命名空间中 可以有同名类**
3.不同命名空间中**互相使用 需要`using`引用命名空间** **或者 指明出处**
4.**命名空间可以包裹命名空间**

#### 基本概念

==概念:==
**命名空间**是用来**组织和重用代码的**
==作用:==
就像一个工具包 **类**就像是一件件的工具 **都是声明在命名空间中的**

#### 命名空间的使用

基本语法

```c#
namespace 命名空间名
{
    类
    类
}
```

```c#

namespace MyGame
{
    class GameObject
    {

    }
}
//命名空间可以同名
namespace MyGame
{
    //跨命名空间函数也不能同名
    //class GameObject
    //{

    //}
    
    //在同名命名空间函数可以继承
    class Player : GameObject
    {

    }
}
```

#### 不同命名空间中互相使用 需要引用命名空间或指明出处

```c#
using MyGame;//最上面引用命名空间

GameObject g = new GameObject();
MyGame.GameObject g2 = new MyGame.GameObject();
MyGame2.GameObject g3 = new MyGame2.GameObject();
```

#### 不同命名空间中允许有同名类

```c#
namespace MyGame2
{
    //在不同命名空间中 可以有同名类
    class GameObject
    {

    }
    //跨命名空间继承
    class Player : MyGame.GameObject
    {

    }
}
```

#### 命名空间可以包裹命名空间

```c#
namespace MyGame
{
    namespace UI
    {
        class Images
        {

        }
    }
    namespace Game
    {
        class Images
        {

        }
    }
}
```

#### 关于修饰类的访问修饰符

`public` - 命名空间中的类 默认为`public`
`internal` - 只能在该程序集中使用
`abstract` - 抽象类
`sealed` - 密封类
`partial` - 分部类



---



### 万物之父中的方法

#### 总结

1.虚方法 `toString` **自定字符串转换规则**
2.成员方法 `GetTyper` 反射相关
3.成员方法 `MemberwiseClone` **浅拷贝**
4.虚方法 `Equals` **自定义判断相同的规则**

#### object中的静态方法

**静态方法** `Equals` 判断两个对象是否相等
最终的判决权 交给左侧对象的`Equals`方法
不管**值类型还是引用类型都会按照左侧对象**`Equals`方法**规则来进行比较**

```c#
    class Test
    {
        public int i = 1;
        public Test2 t2 = new Test2();

        public Test Clone()
        {
            return MemberwiseClone() as Test;
        }

        public override string ToString()
        {
            return "自定义ToString()";
        }
    }
    class Test2
    {
        public int i = 2;
    }
```

```c#
//值类型
Console.WriteLine(Object.Equals(1, 1));
//引用类型
Test test = new Test();
Test test1 = new Test();
//Object.Equals可以直接省略Object
Console.WriteLine(Equals(test, test1));
```

静态方法`ReferenceEquals`
比较两个对象是否是相同的引用 **主要是用来比较引用类型的对象**
值类型对象返回值始终是`false`

```c#
test1 = test;
Console.WriteLine(Object.ReferenceEquals(test,test1));
```

#### object中的成员方法

普通方法`GetType()`
该方法在反射相关知识点是非常重要的方法 之后会具体的讲解这里返回的`Type`类型
该方法的主要作用就是获取对象运行时的类型`Type`
通过`Type`结合反射相关知识点可以做很多相关对象的操作

```c#
Test t = new Test();
Type type = t.GetType();
```

普通方法`MemberwiseClone()`
该方法用**于获取对象的浅拷贝** 意思就是会**返回一个新的对象**
但是**新对象中的引用变量会和老对象中一致**

```c#
public Test Clone()
{
    return MemberwiseClone() as Test;
}
```

```c#
Test t2 = t.Clone();
Console.WriteLine("克隆对象后");
Console.WriteLine("t.i = "+t.i);
Console.WriteLine("t.t2.i = "+t.t2.i);
Console.WriteLine("t2.i = "+t2.i);
Console.WriteLine("t2.t2.i = "+t2.t2.i);

t2.i = 20;
t2.t2.i = 21;
Console.WriteLine("改变克隆体信息后");
Console.WriteLine("t.i = " + t.i);
Console.WriteLine("t.t2.i = " + t.t2.i);
Console.WriteLine("t2.i = " + t2.i);
Console.WriteLine("t2.t2.i = " + t2.t2.i);
```

#### object中的虚方法

虚方法`Equals`
默认实现还是比较两者是否同一个引用,相当于`ReferenceEquals`
但是微软在所有值类型的基类`System.ValueType`中重写了该方法 **用来比较值相等**
我们也**可以重写该方法 定义自己的比较相等的规则**

虚方法`GetHashCode`
该方法是**获取对象的哈希码**
(一直通过算法算出的 表示对象的唯一编码 不同对象的哈希码有可能一样 具体值根据哈希算法决定)
我们**可以通过重写该函数来自定义对象的哈希算法** 正常情况下 我们使用的极少 基本不用

虚方法`ToString`
该方法**用于返回当前对象代表的字符串** 我们**可以重写它定义我们自己的对象转字符串规则**
该方法非常常用 当我们调用打印方法时 默认就是使用对象的`ToString`方法后打印出来的内容

```c#
public override string ToString()
{
    return "自定义ToString()";
}
```

```c#
Test t = new Test();
Console.WriteLine(t);//自定义ToString()
```



---



### string

#### 字符串指定位置获取

**字符串本质是char数组**

**转为char数组**
`ToCharArray();`

```c#
string str = "Jie";
Console.WriteLine(str[0]);//J
//转为char数组
char[] chars = str.ToCharArray();
Console.WriteLine(chars[1]);

for (int i = 0; i < str.Length; i++)
{
    Console.WriteLine(str[i]);
}
```

#### 字符串拼接

```c#
str = string.Format("{0}{1}", 1, 111);
Console.WriteLine(str);//1111
```

#### 正向查找字符位置

```c#
str = "我叫吊炸天";
int index = str.IndexOf("叫");//返回数组下标
Console.WriteLine(index);//1
//如果查找不到则返回-1
index = str.IndexOf('你');
Console.WriteLine(index);//-1
```

#### 反向查找指定字符串位置

```c#
str = "我是吊炸天吊炸天";
index = str.LastIndexOf("吊炸天");
Console.WriteLine(index);//5

index = str.LastIndexOf("屌炸天");
Console.WriteLine(index);//-1
```

#### 移除指定位置后的字符

```c#
str = "我是吊炸天吊炸天";
str.Remove(4);
Console.WriteLine(str);//我是吊炸天吊炸天
//需要赋值后才会改变 返回的是单独的一个字符串
str = str.Remove(4);
Console.WriteLine(str);//我是吊炸天

//执行两个参数进行移除
//参数1 开始位置
//参数2 移除的字符个数
str = "我是吊炸天吊炸天";
str = str.Remove(1, 1);
Console.WriteLine(str);//我吊炸天吊炸天
```

#### 替换指定字符串

```c#
str = "我是吊炸天吊炸天";
str.Replace("吊炸天", "废人弱");
Console.WriteLine(str);//我是吊炸天吊炸天
//重新赋值才会生效
str = str.Replace("吊炸天", "废人弱");
Console.WriteLine(str);//我是废人弱废人弱
```

#### 大小写转换

```c#
str = "asdasdasdasd";
//大写
str.ToUpper();
Console.WriteLine(str);//asdasdasdasd
str = str.ToUpper();
Console.WriteLine(str);//ASDASDASDASD
//小写
str = str.ToLower();
Console.WriteLine(str);//asdasdasdasd
```

#### 字符串截取

```c#
str = "我是吊炸天吊炸天";
Console.WriteLine(str);//我是吊炸天吊炸天
//截取从指定位置开始之后的字符串
str = str.Substring(2);
Console.WriteLine(str);//吊炸天吊炸天

//参数1 开始位置
//参数2 指定截取个数
//不会自动的帮助你判断是否越界 需要自己去判断
str = str.Substring(2, 2);//天吊
Console.WriteLine(str);
```

#### 字符串切割

```c#
str = "1_1,2_2,3_3,4_1,5_2";
string[] strs = str.Split(',');//使用,切割返回数组
for (int i = 0; i < strs.Length; i++)
{
    Console.WriteLine(strs[i]);//(依次打印)1_1    2_2		3_3		4_1		5_2
}
```



---



### StringBuilder

#### 基本概念

C#提供的一个用于处理字符串的公共类
==主要解决的问题是:==
**修改字符串而不创建新的对象** 需要频繁修改和拼接的字符串可以使用它 **可以提升性能**
使用前 **需要引用命名空间**

#### 初始化 直接指明内容

```c#
StringBuilder str = new StringBuilder("123123123");
//参数1:传入的内容
//参数2:单个房间的最大容量   不写 默认16
//StringBuilder str = new StringBuilder("123123123",100);
Console.WriteLine(str);//123123123
```

#### 容量

```c#
//StringBuilder 存在一个容量的问题 每次往里面增加时 会自动扩容 扩容*2(如默认16超出了 容量变成32 在超出了变64 依次*2... )
//获得容量
Console.WriteLine(str.Capacity);
//获得字符长度
Console.WriteLine(str.Length);
```

#### 增删改查替换

```c#
//增
str.Append("000");
Console.WriteLine(str);
Console.WriteLine(str.Length);
Console.WriteLine(str.Capacity);

str.AppendFormat("{0}{1}",100,100);
Console.WriteLine(str);
Console.WriteLine(str.Length);
Console.WriteLine(str.Capacity);

//插入
//参数1:插入的位置
//参数2:插入的内容
str.Insert(0, "Yue");
Console.WriteLine(str);

//删
//参数1:开始位置  参数2:删除的数量
str.Remove(0, 10);

//清空
str.Clear();

//查
str.Append("0100000");
Console.WriteLine(str[1]);
//改
str[0] = 'A';
Console.WriteLine(str);
//替换
str.Replace("1", "666");
Console.WriteLine(str);

//重新赋值 StringBuilder
//只能先清空 在拼接
str.Clear();
str.Append("123123");
Console.WriteLine(str);

//判断StringBuilder是否和某个字符串相等
if (str.Equals("123123"))
{
    Console.WriteLine("相等");
}
```

#### 描述string 和 stringBuilder的区别

1.`string`相对于`StringBuilder` 更容易产生垃圾 **每次修改拼接都会产生垃圾**
2.`string`相对`StringBuilder`更加灵活 因为**它提供了更多的方法**提供使用
**如何选择他们两个**
需要**频繁修改拼接的字符串**可以使用`StringBuilder`
**需要**使用`string`**独特的一些方法来处理一下特殊逻辑时**可以使用`string`

#### 如何优化内存

**内存优化** 从两个方面去解答
1.如何节约内存
2.如何尽量少的GC(垃圾回收)

**少new对象 少产生垃圾**
**合理使用static(静态)**
**合理使用string和StringBuilder**



---



### 结构体和类的区别

#### 区别概述

结构体和类**最大的区别就是在存储空间上** 因为**结构体是值类型 类是引用类型**
因此他们的存储位置一个在栈上 一个在堆上
通过之前知识点的学习 可以看出他们在使用的区别(**值类型和引用类型赋值的区别**)

结构体和类在使用上很类似 结构体甚至可以用面向对象的思想来形容一类对象
**结构体具备着面向对象思想中封装的特性** **但**是它**不具备继承和多态的特性** 因此大大减少了他的使用频率
由于**结构体**不具备继承的特性 所以它**不能**够使用`protected`保护访问修饰符

#### 细节区别

1**.结构体是值类型,类是引用类型**
2.**结构体存在栈中,类存在堆中**
3.**结构体成员不能**使用`protected`访问修饰符,而类可以
4.**结构体成员变量声明不能指定初始值**,而类可以
5.**结构体不能声明无参构造函数**,而类可以
6.**结构体声明有参构造函数后,无参不会被顶掉**,而类会
7.**结构体不能声明析构函数,而类可以**
8.**结构体不能被继承,而类可以**
9.**结构体需要再构造函数中初始化所有成员变量**,而类随意
10.**结构体不能被静态static修饰**(不存在静态结构体),而类可以
11.**结构体不能再自己内部声明和自己一样的结构体变量**,而类可以

#### 结构体的特别之处

**结构体可以继承 接口** 因为接口是行为的抽象

#### 如何选择结构体和类

1.**想要**用**继承和多态**时 **直接选择类**,比如**玩家** **怪物**等等
2.对象是**数据集合**时 **优先考虑结构体** 比如**位置** **坐标**等等
3.**从值类型和引用类型赋值时的区别去考虑** 比如经常被赋值传递的对象,并且
**改变赋值对象 原对象不行跟着变化时 就用结构体** 比如**坐标 向量 旋转**等等



---



### 抽象类和接口的区别

#### 知识回顾

抽象类和抽象方法
`abstract`修饰的类和方法
抽象类 不能实例化
抽象方法只能在抽象类中声明 是个纯虚方法 必须在子类实现

接口
`interface` 自定义类型
是行为的抽象
不包含成员变量
仅包含方法 属性 索引器 事件 成员都不能实现 剪映不写访问修饰符 默认`public`

#### 相同点

1.都可以被继承
2.**都不能直接实例化**
3.都可以包含方法声明
4.**子类必须实现为实现的方法**
5.**都遵循里氏替换原则**

#### 区别

1.抽象类中可以有构造函数;接口中不能
2.抽象类只能被单一继承 **接口可以被继承多个**
3.**抽象类中可以有成员变量;**接口不能
4.抽象类中可以声明成员方法,虚方法,抽象方法,静态方法;**接口只能声明没有实现的抽象方法**
5.抽象类方法可以使用访问修饰符;接口中建议不写 默认`public`

#### 如何选择抽象类和接口

标识**对象的用抽象类** 标识**行为扩展的用接口**
不同对象拥有的共同行为,我们往往可以使用接口来实现

举个例子:
**动物是一类对象** 我们自然会选择**抽象类**, 而飞翔是一个**行为** 我们自然会**选择接口**



---



# C#进阶



